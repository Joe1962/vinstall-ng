' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.
'====================================================================================================

' PUBLIC objinitrds AS Object[]
' PUBLIC objChecks AS Object[]
' PUBLIC objappends AS Object[]
' PUBLIC objNames AS Object[]
PUBLIC bScanned AS Boolean

PUBLIC FUNCTION ID_LINUX(sMountedLocation AS String) AS String
  DIM sRes AS String
  DIM sDump AS String
  IF Exist(sMountedLocation &/ "etc/arch-release") THEN 
    sRes = "Arch"
  ELSE IF Exist(sMountedLocation &/ "etc/knoppix-version") THEN 
    sRes = "Knoppix"
  ELSE IF Exist(sMountedLocation &/ "etc/sidux-version") THEN 
    sRes = "Sidux"
  ELSE IF Exist(sMountedLocation &/ "etc/debian_version") THEN 
    SHELL "grep -m 1 cdrom " & sMountedLocation &/ "etc" &/ "apt" &/ "sources.list | cut -d \"[\" -f2 | cut -d \" \" -f 1,2" TO sres
      IF Len(Trim(sres)) >= 0 THEN 
        sres = Trim(Replace(sres, " ", "_"))
      ELSE 
        sres = "Debian"
      END IF
  ELSE IF Exist(sMountedLocation &/ "/etc/gentoo-release") THEN 
    sres = "Gentoo"
  ELSE IF Exist(sMountedLocation &/ "/etc/redhat-release") THEN 
    sres = "RedHat"
  ELSE IF Exist(sMountedLocation &/ "/etc/pclinuxos-release") THEN 
    sres = "PCLinuxOS"
  ELSE IF Exist(sMountedLocation &/ "/etc/mandriva-release") THEN 
    sres = "Mandriva"
  ELSE IF Exist(sMountedLocation &/ "/etc/mandrake-release") THEN 
    sres = "Mandriva"
  ELSE IF Exist(sMountedLocation &/ "etc/vector-version") THEN 
    'sres = "VectorLinux"
      'sDump = File.Load(sMountedLocation &/ "etc/vector-version")
      SHELL "cat " & sMountedLocation &/ "etc/vector-version" TO sDump
      'Message(sDump)
        IF InStr(sDump, "Light") THEN 
          sRes = "VL-Light"
        ELSE IF InStr(sDump, "Standard") THEN 
          sRes = "VL-STD"
        ELSE IF InStr(sDump, "SOHO") THEN 
          sRes = "VL-SOHO"
        ELSE IF InStr(sDump, "Deluxe") THEN 
          sRes = "VL-SOHO DLX"
        ELSE 
          sRes = "VectorLinux"
        END IF
        'IF InStr sDump LIKE "Light" THEN 
          
  ELSE IF Exist(sMountedLocation &/ "etc/slackware-version") THEN 
    sres = "Slackware"
  ELSE IF Exist(sMountedLocation & "/etc/SuSE-release") THEN
    sres = "SuSE"
  ELSE IF Exist(sMountedLocation &/ "yellowdog-release") THEN 
    sres = "YellowDog"
  ELSE IF Exist(sMountedLocation &/ "etc/zenwalk-version") THEN 
    sres = "Zenwalk"
  ELSE IF Exist(sMountedLocation &/ "etc/fedora-release") THEN 
    sres = "Fedora"
  ELSE 
    sres = "Linux"
  END IF
  

  
  RETURN sres
  
END


PUBLIC FUNCTION Find_Linux(sPartition AS String) AS String
  ' None: No linux found
  ' Linux: Unknown linux found
  ' DISTRO_NAME: DISTRO_NAME found
  ' Fail: Error running function

DIM sAddr AS String = Right(sPartition, Len(sPartition) - RInStr(sPartition, "/"))
DIM sTempTarget AS String = "/mnt" &/ sAddr
DIM sres AS String


  SHELL "mkdir -p /mnt" &/ sAddr & Space(1) & "2>/dev/null" WAIT 
  SHELL "mount " & sPartition & Space(1) & "/mnt" &/ sAddr & Space(1) & "2>/dev/null" WAIT 
  
    ' perform test to see if there is a linux partition here
    IF IsDir(sTempTarget &/ "boot") THEN ' this feels like linux here
      IF IsDir(sTempTarget &/ "etc") THEN ' this is definitely linux
        ' ============== IDENTIFY LINUX DISTRO ====================
        sres = ID_LINUX(sTempTarget)
        
      END IF
    END IF
  IF Len(Trim(sres)) > 0 THEN 
    sRes = Trim(sRes)
  ELSE 
    sRes = "None"
  END IF
  RETURN sres
  
  
  
END
' PUBLIC SUB populate_linux_entry(sLinux AS String, sLinuxRoot AS String, objTabStrip AS TabStrip)
'   
'   DIM i AS Integer
'   DIM tb AS TextBox
'   DIM tl AS TextLabel
'   DIM cb AS CheckBox
'   DIM hb AS HBox
'   DIM comb AS ComboBox
'   
'   IF NOT sLinux OR Len(Trim(sLinux)) <= 0 THEN RETURN 
'   'Message(sLinux)
'   IF sLinuxRoot = ClsGlobal.sRoot THEN ' This is the just installed linux
'     i = 0
'       WITH objTabStrip
'         .Index = i
'         .Text = "VectorLinux"
'       END WITH 
'   ELSE 
'   i = objTabStrip.Count - 1
'     WITH objTabStrip
'       .Index = i
'       .Text = sLinux
'     END WITH 
'   END IF
'   
'   tl = NEW TextLabel(objTabStrip) AS "Banner"
'     WITH tl
'       .Text = ("Installation found in") & Space(1) & sLinuxRoot
'       .Height = 24
'       .Alignment = Align.Left
'       .Width = 200
'       .Expand = TRUE
'       '.Border = Border.Plain
'       '.AutoResize = TRUE
'       .Move(4, 4)
'     END WITH 
'   hb = NEW HBox(objTabStrip) ' separator space
'     WITH hb
'       .Height = 16
'       .Width = 12
'       .Expand = TRUE
'     END WITH 
'   cb = NEW CheckBox(objTabStrip) ' Inlcude/Exclude OS from boot menu
'     WITH cb
'       .Expand = TRUE
'       .Text = ("Include in boot menu")
'       .Value = TRUE
'       .Height = 24
'       .Tag = sLinuxRoot
'     END WITH 
'     objChecks.Add(cb)
'   hb = NEW HBox(objTabStrip) ' separator space
'     WITH hb
'       .Height = 12
'       .Expand = TRUE
'     END WITH 
'   hb = NEW HBox(objTabStrip) ' This will hold a few objects of it's own
'     WITH hb
'       .Height = 28
'       .Expand = TRUE
'       .Padding = 2
'       .Spacing = 2
'     END WITH 
'   tl = NEW TextLabel(hb) ' Name label
'     WITH tl
'       .Text = ("Name")
'       .Expand = FALSE
'       .Width = 200
'       .Adjust()
'       .AutoResize = TRUE
'       .Height = .Parent.Height
'       .Alignment = Align.Left
'     END WITH 
'   tb = NEW TextBox(hb) AS "tbOsLabel" ' Name entry box
'     WITH tb
'       .Expand = TRUE
'       .Height = .Parent.Height
'       .Text = sLinux '  default to the distro found
'       .Tag = sLinuxRoot
'     END WITH 
'     objNames.Add(tb)
'   tl = NEW TextLabel(hb) ' initrd label
'     WITH tl
'       .text = ("Initial RAM disk image")
'       .Alignment = Align.Right
'       .Height = .Parent.Height
'       .Expand = TRUE
'     END WITH 
'     
'   comb = NEW ComboBox(hb) ' initrd selection combobox
'     WITH comb
'       .Height = .Parent.Height
'       .Expand = TRUE
'       .READonly = TRUE
'       .Tag = sLinuxRoot
'     END WITH 
'       ' populate the initrd box
'       'Message(sLinuxRoot)
'         ME.find_initrds_for_this_linux(sLinuxRoot, comb) ' populate initrd selection
'         
'     objinitrds.Add(comb)
'   hb = NEW HBox(objTabStrip) ' blank space separator
'   hb.Height = 8
'   hb.Expand = TRUE
'   tl = NEW TextLabel(objTabStrip) ' append line textlabel
'     WITH tl
'       .Text = ("Kernel boot options")
'       .Height = 24
'       .Width = 200
'       .Alignment = Align.Left  objappends = NEW Object[]
  ' objChecks = NEW Object[]
  ' objinitrds = NEW Object[]
  ' objNames = NEW Object[]
  
'       .Expand = FALSE
'       .AutoResize = TRUE
'     END WITH 
'   tb = NEW TextBox(objTabStrip) ' append input line
'     WITH tb
'       .Text = "splash=silent"
'       .Height = 24
'       .Expand = TRUE
'       .Tag = sLinuxRoot
'     END WITH 
'       objappends.Add(tb)
'     
'     ' ======================= ONLY FOR THE OS WE JUST INSTALLED ===============================
'   IF sLinuxRoot = ClsGlobal.sRoot THEN 
'     hb = NEW HBox(objTabStrip) ' yet another separator
'       WITH hb
'         .Expand = TRUE
'         .Height = 8
'       END WITH 
'     cb = NEW CheckBox(objTabStrip) AS "bCLIOption"
'       WITH cb
'         .Value = TRUE
'         .Text = ("Add option to boot this operating system into text mode")
'         .Height = 24
'         .Expand = TRUE
'         .Tag = sLinuxRoot
'       END WITH 
'     ' hb = NEW HBox(objTabStrip)
'     '   hb.Height = 4
'     '   hb.Expand = TRUE
'       
'   END IF
'     objTabStrip.Refresh()
'   
'       
'   
' END


' PUBLIC SUB List_Other_Linuxes(objTabStrip AS TabStrip) ' tell me where you want the results.
  
'   DIM sDump, sPartitions, sPart AS String
'   DIM sPartList AS String[]
'   DIM i AS Integer
'   DIM sOutcome AS String
'   
'   objappends = NEW Object[]
'   objChecks = NEW Object[]
'   objinitrds = NEW Object[]
'   objNames = NEW Object[]
'   
'   bScanned = TRUE
'               'Message(ClsGlobal.sRoot)
' '            Message(Trim(sPartList[i]))
'   
'   ' First, and foremost, we will list the recently isntalled VectorLinux
'     'populate_linux_entry("VectorLinux", ClsGlobal.sRoot, objTabStrip) ' This will list the newly isntall VL OS
'   ' Now list all other linuxes =================================================
'       SHELL "probepart | grep \"^/dev\" | grep -vi swap | grep -i linux | tr -s \' \' | cut -f 1 -d \' \'" TO sDump
'         sDump = Trim(sDump)
'           IF Len(sDump) <= 0 THEN RETURN ' nothing found, VL is the only distro in this box ... 
'         sPartList = Split(sDump, gb.NewLine)
'           FOR i = 0 TO sPartList.Max
'             sPart = Trim(Right(sPartList[i], Len(sPartList[i]) - RInStr(sPartList[i], "/")))
' 
'               'IF Trim(ClsGlobal.sRoot) <> Trim(sPartList[i]) THEN 
'                 'sOutcome = Find_Linux(Trim(sPartList[i]))
'                 'Message(sOutcome)
'               ' will only list the linux IF one IS present
'                 'IF Trim(sPartList[i]) <> Trim(ClsGlobal.sRoot) THEN
'                 'IF Find_Linux(Trim(sPartList[i])) <> "None" THEN 
'                 sOutcome = Find_Linux(Trim(sPartList[i]))
'                   IF sOutcome AND sOutcome <> "None" THEN 
'                   'INC objTabStrip.Count
'                   objTabStrip.Index = objTabStrip.Count - 1
'                   populate_linux_entry(sOutcome, Trim(sPartList[i]), objTabStrip)
'                   INC objTabStrip.Count
'                 END IF
'               'END IF
'                 
'           NEXT 
'         DEC objTabStrip.Count ' remove the trailing blank tab from the tabstrip.
'         
'   
'   ' now list all other Windows os's ============================================
'     
'   
' END


PUBLIC SUB find_initrds_for_this_linux(sLinuxRoot AS String, object AS ComboBox)
  
  DIM sResults AS String
  DIM slines AS String[]
  DIM i AS Integer
  DIM sAdd, sBootPath AS String
    ' need to find the mounted address to this linux
    sAdd = Replace(sLinuxRoot, "/dev/", "/mnt/")
      IF sLinuxRoot = ClsGlobal.sRoot THEN 
        sBootPath = sadd &/ "boot"
      ELSE 
        sBootPath = sAdd &/ "boot"
      END IF
    SHELL "ls " & sBootPath & " | grep initrd" TO sResults
      sResults = Trim(sResults)
      'Message(sResults)
      IF NOT sResults THEN ' initrds are not located in the /boot directory
        SHELL "ls " & sadd & " | grep initrd" TO sResults
      END IF
      
      sResults = Trim(sResults)      
      
        slines = Split(sResults, "\n")
          FOR i = 0 TO slines.Max
            IF Len(Trim(slines[i])) > 0 THEN object.Add(Trim(slines[i]))
          NEXT 
          object.Add(("None"))
  
END

PUBLIC SUB GENERATE_LILO_HEADER()
  
  DIM sTmp AS String
  DIM sTarget, sVidMod, sDefBoot, sVGA, sVidImput, sVidText, sOutput AS String
  DIM iTimeOut AS Integer
  
  sTarget = Trim(Conf0.cbTarget.Text)
    IF InStr(sTarget, ("MBR Of")) THEN 
      sTarget = Right(sTarget, Len(sTarget) - InStr(sTarget, "/") + 1)
    ELSE IF sTarget = ("Bootsector Of") & Space(1) & ClsGlobal.sRoot THEN 
      sTarget = ClsGlobal.sRoot
    ELSE IF sTarget = ("Floppy") THEN 
      sTarget = "/dev/df0"
    END IF
    
  sVidImput = Trim(Conf0.cbVidRes.Text)
    SELECT CASE sVidImput
      CASE ("Standard")
        sVGA = "normal"
      CASE ("Bootsplash Med")
        svga = "788"
      CASE ("Bootsplash High")
        svga = "791"
      CASE ("Bootsplash Extra High")
        svga = "794"
      END SELECT 
      
    sVidText = "# VESA framebuffer console @ 1024x768x64k \n" &
"vga = " & sVga & "\n" &
"# Normal VGA console \n" &
"#vga = normal \n" &
"#VESA framebuffer console @ 1024 x768x64k \n" &
"#vga = 791 \n" &
"#VESA framebuffer console @ 1024 x768x32k \n" &
"#vga = 790 \n" &
"#VESA framebuffer console @ 1024 x768x256 \n" &
"#vga = 773 \n" &
"#VESA framebuffer console @ 800 x600x64k \n" &
"#vga = 788 \n" &
"#VESA framebuffer console @ 800 x600x32k \n" &
"#vga = 787 \n" &
"#VESA framebuffer console @ 800 x600x256 \n" &
"#vga = 771 \n" &
"#VESA framebuffer console @ 640 x480x64k \n" &
"#vga = 785 \n" &
"#VESA framebuffer console @ 640 x480x32k \n" &
"#vga = 784 \n" &
"#VESA framebuffer console @ 640 x480x256 \n" &
"#vga = 769 \n" &
"# Begin listing OS Choices \n" 

    
  sDefBoot = Conf0.cbDefBoot.Tag  
  iTimeOut = Conf0.SbTimeOut.Value * 10
  
  sOutput = "# LILO Configuration File \n" &
  "# Generated by the VectorLinux Installer \n \n" &
  "# Begin lilo global configuration \n \n" &
  "boot = " & sTarget & "\n" &
  "default = " & sDefBoot & "\n" &
  "prompt \n" &
  "compact \n" &
  "timeout = " & iTimeOut & "\n" &
  "#\n#\n#\n" &
  "# Override dangerous defaults that require the partition table: \n" &
  "change-rules \n" &
  "reset \n" &
  "bitmap = /boot/bitmap/boot.bmp \n" &
  "#\n\n" &
  sVidText
  
  File.Save(Temp("lilo.in"), sOutput)
  
  'Message(File.Load(Temp("lilo.in")))

END

PUBLIC SUB SETUP_LILO_BOOT_MANAGER()
  
  DIM cbx AS CheckBox
  DIM cb AS ComboBox
  DIM tl AS TextLabel
  DIM sKernel, sInitrd, sArch AS String
  
  ' find kernels and initrds, copy them to /boot on the target dir
  ' can't use /boot/tamu anymore... all has to go into /boot
  FOR EACH cbx IN Conf0.objMenuObjects
    IF cbx.Value = TRUE THEN 
      FOR EACH tl IN Conf0.objKernels
        IF cbx.Tag = tl.Name THEN sKernel = tl.Tag
      NEXT 
      FOR EACH cb IN Conf0.objinitrds
        IF cb.tag = tl.Name THEN sInitrd = cb.Text

      NEXT 
      
      ' now that we got kernel and initrd, copy them over
      IF sKernel AND IF sInitrd THEN 
        SHELL "cp " & sKernel & Space(1) & ClsGlobal.sTargetPath &/ "boot"
        SHELL "cp " & sInitrd & Space(1) & ClsGlobal.sTargetPath &/ "boot"
      END IF
      
  NEXT 
  
  ' determine wether we need to update modules
  EXEC ["uname", "-r"] TO sArch
    IF Exist("/lib" &/ "modules" &/ Trim(sArch)) = FALSE THEN ' hosted install detected
      EXEC ["mkdir", "-p", "/lib" &/ "modules" &/ Trim(sArch)] WAIT 
      SHELL "mount -o bind " & ClsGlobal.sTargetPath &/ "lib/modules" &/ Trim(sArch) & Space(1) & "/lib/modules" &/ Trim(sarch) & " && depmod -aq" WAIT 
    END IF
      
  
  ' now that kernels have been copied, I need to run lilo
  ' Bind mount the target /tmp and sys dirs  now
  ' See PUBLIC SUB_PERFORM_BINDING on iVL branch
  EXEC ["mount", "-o", "bind", "/sys", ClsGlobal.sTargetPath &/ "sys"] WAIT 
  EXEC ["mount", "-o", "bind", "/proc", ClsGlobal.sTargetPath &/ "proc"] WAIT 
  EXEC ["mount", "-o", "bind", "/tmp", ClsGlobal.sTargetPath &/ "tmp"] WAIT 
  EXEC ["mount", "-o", "bind", "/dev", ClsGlobal.sTargetPath &/ "dev"] WAIT 
  
  ' now, we need to run the lilo command itself
  SHELL "chroot " & ClsGlobal.sTargetPath & " && /sbin/depmod -aq && lilo " WAIT 
  
END


PUBLIC SUB GENERATE_LILO_OS_LIST()
  
  DIM ckb AS CheckBox
  DIM cb AS ComboBox
  DIM tb AS TextBox
  DIM tl AS TextLabel
  DIM sTitle, sRoot, sInitrd, sKernel, sAppend AS String
  DIM sBody AS String
  DIM sHeader, sFullFile AS String
  
  FOR EACH ckb IN Conf0.objMenuObjects
    IF ckb.Value = TRUE THEN 
      sRoot = ckb.Tag
      FOR EACH tb IN Conf0.objNames
        IF tb.Tag = ckb.Tag THEN sTitle = tb.Text
      NEXT 
      ' get the initrd
      FOR EACH cb IN Conf0.objinitrds
        IF cb.Tag = sRoot THEN sInitrd = Trim(cb.Text)
      NEXT 
      ' get the append line
      FOR EACH tb IN Conf0.objappends
        IF tb.tag = sRoot THEN sAppend = tb.Text
      NEXT 
      FOR EACH tl IN Conf0.objKernels
        IF tl.Name = sRoot THEN sKernel = tl.Tag
      NEXT
          sBody = sBody & gb.NewLine & 
          "# Menu entry for " & sTitle & "\n" &
          "image = " & Trim(sKernel) & "\n" &
          "root = " & sRoot & "\n" &
          "label = " & sTitle & "\n" &
          "append = \"" & sAppend & "\"\n" &
          "read-only \n"
          'IF sBody THEN Message(Trim(sBody))
    END IF
    
    ' Reset these variables for future use
    sKernel = ""
    sRoot = ""
    sTitle = ""
    sAppend = ""
  NEXT 
  'IF sBody THEN Message(sBody)
  'load the header
    sHeader = File.Load(Temp("lilo.in"))
    sFullFile = sHeader & sBody
    'Message(sFullFile)
    IF Exist(ClsGlobal.sTargetPath &/ "etc/lilo.conf") THEN MOVE ClsGlobal.sTargetPath &/ "etc/lilo.conf" TO ClsGlobal.sTargetPath &/ "etc/lilo.old"
    
    File.Save(ClsGlobal.sTargetPath &/ "etc/lilo.conf", Trim(sFullFile))
END



PUBLIC SUB Display_Bootmanager_Target_Options(objCB AS ComboBox)
  
  DIM sList, sTarget, sDump AS String
  DIM sListArr AS String[]
  DIM i AS Integer
  DIM cb, cbl AS ComboBox
  
  SHELL "probedisk | grep -vi cdrom | cut -f 1 -d \'|\'" TO sList
  sList = Trim(sList)
  
  sListArr = Split(sList, "\n").Sort(gb.Ascent)
    FOR i = 0 TO sListArr.Max
    sTarget = ("MBR of") & Space(1) & Trim(sListArr[i])    
      objCB.Add(Trim(sTarget))
    NEXT 
    
    'Determine how the root partition was formatted
      SHELL "df -hT " & ClsGlobal.sTargetPath & " | tr -s \' \' | grep \"^/dev\" | cut -f 2 -d \' \'" TO sDump
      sDump = Trim(sDump)
    IF LCase(sDump) <> "xfs" THEN 
      objCB.Add(("Bootsector of") & Space(1) & ClsGlobal.sRoot)
      
    END IF      
  
END

' PUBLIC SUB PROBE_SYSTEM_FOR_OS(sBootManager AS String)
'   
'   DIM sDump, sOs, sRoot, sLongDesc, sType, sTitle AS String
'   DIM i AS Integer
'   DIM sOsList, sOsLine, sBootLine, sDumparr AS String[]
'   DIM sKernel, sInitrd, sAppendLine AS String
'   DIM sBootargs AS String
'   
'   sOsList = Split(Trim(File.Load("/tmp/os.lst")), gb.NewLine)
'     FOR i = 0 TO sOsList.Max
'       sOsLine = Split(Trim(sOsList[i]), ":")
'        sType = Trim(sOsLine[3])
'        sLongDesc = Trim(sOsLine[1])
'        sOs = Trim(sOsLine[2])
'        sRoot = Trim(sOsLine[0])
'         IF sBootManager LIKE "lilo" THEN 
'           sTitle = sOs
'         ELSE 
'           sTitle = sLongDesc
'         END IF
'        
'         '  Message(sLongDesc & " was found in " & sRoot)
'         ' -= NOW I NEED TO GET THE KERNEL, INITRD AND APPEND LINES FOR THIS OS. =-
'           IF sType LIKE "linux" THEN 
'             ' this function will return an array separated by "," in this order
'             ' /path/to/kernel, /path/to/initrd, appendline here
'             
'             sBootargs = Get_OS_Boot_Params(sRoot)
'               IF NOT (sBootargs) THEN 
'                 '= CAN NOT FIND BOOT ARGUMENTS FOR THIS OS ='
'                   PRINT ("Unable to find boot arguments for OS in") & Space(1) & sRoot
'                 RETURN 
'               ELSE 
'                 Message(sTitle & "<br>" & sBootargs)
'               END IF
'               
'           END IF
'             
'     NEXT 
'   
' END

PUBLIC FUNCTION Get_OS_Boot_Params(sOsRoot AS String) AS String
  
  DIM $kern, $initrd, $append, sDump AS String
  DIM i AS Integer
  DIM $dumparr, $linearr AS String[]
  DIM $file AS String = "/tmp/bootargs.lst"
  DIM $line AS String
  'dim sListarr as String[] = Split(Trim(File.Load("/tmp/bootargs.
  
  SHELL "cat " & $file & " | grep ^" & sOsRoot TO sDump
    sDump = Trim(sDump)
      $dumparr = Split(sDump, gb.NewLine)
      ' always grab the first line only for each os
      $line = Trim($dumparr[0])
        IF NOT ($line) THEN RETURN 
      $append = Right($line, Len($line) - InStr($line, "append") + 1) & "\""
      $linearr = Split($line, ":")
        $kern = Trim($linearr[3])
        $initrd = Trim($linearr[4])
        
  
  RETURN $kern & "," & $initrd & "," & $append
        
END

PUBLIC FUNCTION CHECK_LILO_VALUES(bquiet AS Boolean) AS Integer
  
  ' will return 0 for clear
  ' 1 for error
  DIM tb, tb1, tb2 AS TextBox
  DIM cb AS CheckBox
  DIM sTag AS String = Conf0.TsOsList.Current.Text
    IF NOT (Conf0.cbDefBoot.tag) THEN 
      IF bquiet = FALSE THEN 
      Message.Error(("You must select one operating system to be started by default"))
      END IF
        FOR EACH cb IN Conf0.objDefOs
          IF cb.Tag = sTag THEN 
            IF bquiet = FALSE THEN Balloon.Error(("Check this box to make this your default operating system, or select another tab."), cb, cb.Left + 24)
          END IF
        NEXT 
      RETURN 1
    END IF
  FOR EACH tb IN Conf0.objNames
    FOR EACH tb1 IN Conf0.objNames
      IF tb <> tb1 AND IF tb.Text = tb1.Text THEN 
        IF bquiet = FALSE THEN Message.Error(("Found duplicate operating system names. Please use unique labels for each menu entry"))
          FOR EACH tb2 IN Conf0.objNames
            IF tb2.Tag = sTag THEN 
              IF bquiet = FALSE THEN Balloon.Error(("Check these boxes to make sure they have unique names"), tb2, tb2.Left + 24)
            END IF
          NEXT 
        RETURN 1
      END IF
    NEXT 
  NEXT 
    
  
END

