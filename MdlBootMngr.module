' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.
'====================================================================================================

' PUBLIC objinitrds AS Object[]
' PUBLIC objChecks AS Object[]
' PUBLIC objappends AS Object[]
' PUBLIC objNames AS Object[]
PRIVATE $chroot AS Process
PUBLIC bScanned AS Boolean
PUBLIC sVidMode AS String
PUBLIC objMenuEntries AS NEW Object[]

PUBLIC FUNCTION ID_LINUX(sMountedLocation AS String) AS String
  DIM sRes AS String
  DIM sDump AS String
  IF Exist(sMountedLocation &/ "etc/arch-release") THEN 
    sRes = "Arch"
  ELSE IF Exist(sMountedLocation &/ "etc/knoppix-version") THEN 
    sRes = "Knoppix"
  ELSE IF Exist(sMountedLocation &/ "etc/sidux-version") THEN 
    sRes = "Sidux"
  ELSE IF Exist(sMountedLocation &/ "etc/debian_version") THEN 
    SHELL "grep -m 1 cdrom " & sMountedLocation &/ "etc" &/ "apt" &/ "sources.list | cut -d \"[\" -f2 | cut -d \" \" -f 1,2" TO sres
      IF Len(Trim(sres)) >= 0 THEN 
        sres = Trim(Replace(sres, " ", "_"))
      ELSE 
        sres = "Debian"
      END IF
  ELSE IF Exist(sMountedLocation &/ "/etc/gentoo-release") THEN 
    sres = "Gentoo"
  ELSE IF Exist(sMountedLocation &/ "/etc/redhat-release") THEN 
    sres = "RedHat"
  ELSE IF Exist(sMountedLocation &/ "/etc/pclinuxos-release") THEN 
    sres = "PCLinuxOS"
  ELSE IF Exist(sMountedLocation &/ "/etc/mandriva-release") THEN 
    sres = "Mandriva"
  ELSE IF Exist(sMountedLocation &/ "/etc/mandrake-release") THEN 
    sres = "Mandriva"
  ELSE IF Exist(sMountedLocation &/ "etc/vector-version") THEN 
    'sres = "VectorLinux"
      'sDump = File.Load(sMountedLocation &/ "etc/vector-version")
      SHELL "cat " & sMountedLocation &/ "etc/vector-version" TO sDump
      'Message(sDump)
        IF InStr(sDump, "Light") THEN 
          sRes = "VL-Light"
        ELSE IF InStr(sDump, "Standard") THEN 
          sRes = "VL-STD"
        ELSE IF InStr(sDump, "SOHO") THEN 
          sRes = "VL-SOHO"
        ELSE IF InStr(sDump, "Deluxe") THEN 
          sRes = "VL-SOHO DLX"
        ELSE 
          sRes = ClsGlobal.sDistroName
        END IF
        'IF InStr sDump LIKE "Light" THEN 
          
  ELSE IF Exist(sMountedLocation &/ "etc/slackware-version") THEN 
    sres = "Slackware"
  ELSE IF Exist(sMountedLocation & "/etc/SuSE-release") THEN
    sres = "SuSE"
  ELSE IF Exist(sMountedLocation &/ "yellowdog-release") THEN 
    sres = "YellowDog"
  ELSE IF Exist(sMountedLocation &/ "etc/zenwalk-version") THEN 
    sres = "Zenwalk"
  ELSE IF Exist(sMountedLocation &/ "etc/fedora-release") THEN 
    sres = "Fedora"
  ELSE 
    sres = "Linux"
  END IF
  

  
  RETURN sres
  
END


PUBLIC FUNCTION Find_Linux(sPartition AS String) AS String
  ' None: No linux found
  ' Linux: Unknown linux found
  ' DISTRO_NAME: DISTRO_NAME found
  ' Fail: Error running function

DIM sAddr AS String = Right(sPartition, Len(sPartition) - RInStr(sPartition, "/"))
DIM sTempTarget AS String = "/mnt" &/ sAddr
DIM sres AS String


  SHELL "mkdir -p /mnt" &/ sAddr & Space(1) & "2>/dev/null" WAIT 
  SHELL "mount " & sPartition & Space(1) & "/mnt" &/ sAddr & Space(1) & "2>/dev/null" WAIT 
  
    ' perform test to see if there is a linux partition here
    IF IsDir(sTempTarget &/ "boot") THEN ' this feels like linux here
      IF IsDir(sTempTarget &/ "etc") THEN ' this is definitely linux
        ' ============== IDENTIFY LINUX DISTRO ====================
        sres = ID_LINUX(sTempTarget)
        
      END IF
    END IF
  IF Len(Trim(sres)) > 0 THEN 
    sRes = Trim(sRes)
  ELSE 
    sRes = "None"
  END IF
  RETURN sres
  
  
  
END


PUBLIC SUB find_initrds_for_this_linux(sLinuxRoot AS String, object AS ComboBox)
  
  DIM sResults AS String
  DIM slines AS String[]
  DIM i AS Integer
  DIM sAdd, sBootPath AS String
    ' need to find the mounted address to this linux
    sAdd = Replace(sLinuxRoot, "/dev/", "/mnt/")
      IF sLinuxRoot = ClsGlobal.sRoot THEN 
        sBootPath = sadd &/ "boot"
      ELSE 
        sBootPath = sAdd &/ "boot"
      END IF
    SHELL "ls " & sBootPath & " | grep initrd" TO sResults
      sResults = Trim(sResults)
      'Message(sResults)
      IF NOT sResults THEN ' initrds are not located in the /boot directory
        SHELL "ls " & sadd & " | grep initrd" TO sResults
      END IF
      
      sResults = Trim(sResults)      
      
        slines = Split(sResults, "\n")
          FOR i = 0 TO slines.Max
            IF Len(Trim(slines[i])) > 0 THEN object.Add(Trim(slines[i]))
          NEXT 
          object.Add(("None"))
  
END

PUBLIC SUB GENERATE_LILO_HEADER()
  
  DIM sTmp AS String
  DIM sTarget, sVidMod, sDefBoot, sVGA, sVidImput, sVidText, sOutput AS String
  DIM iTimeOut AS Integer
  DIM sOsList AS String
  DIM entry AS BootMenuEntry
  
  sTarget = Trim(ClsGlobal.BootMngrTarget)
    IF InStr(sTarget, ("MBR Of")) THEN 
      sTarget = Right(sTarget, Len(sTarget) - InStr(sTarget, "/") + 1)
    ELSE IF sTarget = ("Bootsector Of") & Space(1) & ClsGlobal.sRoot THEN 
      'sTarget = ClsGlobal.sRoot
      sTarget = Right(Trim(sTarget), Len("/dev/sda1"))
      'Message.Info(sTarget)
    ELSE IF sTarget = ("Floppy") THEN 
      sTarget = "/dev/df0"
    END IF
    
  sVidImput = Trim(ME.sVidMode)
    SELECT CASE sVidImput
      CASE ("Standard")
        svga = "normal"
      CASE ("Bootsplash Med")
        svga = "788"
      CASE ("Bootsplash High")
        svga = "791"
      CASE ("Bootsplash Extra High")
        svga = "794"
      END SELECT 
      
    sVidText = "# VESA framebuffer console @ 1024x768x64k \n" &
"vga = " & svga & "\n" &
"# Normal VGA console \n" &
"#vga = normal \n" &
"#VESA framebuffer console @ 1024 x768x64k \n" &
"#vga = 791 \n" &
"#VESA framebuffer console @ 1024 x768x32k \n" &
"#vga = 790 \n" &
"#VESA framebuffer console @ 1024 x768x256 \n" &
"#vga = 773 \n" &
"#VESA framebuffer console @ 800 x600x64k \n" &
"#vga = 788 \n" &
"#VESA framebuffer console @ 800 x600x32k \n" &
"#vga = 787 \n" &
"#VESA framebuffer console @ 800 x600x256 \n" &
"#vga = 771 \n" &
"#VESA framebuffer console @ 640 x480x64k \n" &
"#vga = 785 \n" &
"#VESA framebuffer console @ 640 x480x32k \n" &
"#vga = 784 \n" &
"#VESA framebuffer console @ 640 x480x256 \n" &
"#vga = 769 \n" &
"# Begin listing OS Choices \n"

    IF Conf0.rbLilo.Value = TRUE THEN 
      sOsList = ME.GENERATE_LILO_OS_LIST("lilo")
    ELSE 
      'sOsList = ME.GENERATE_LILO_OS_LIST("grub")
    END IF
  FOR EACH entry IN MdlBootMngr.objMenuEntries
    IF entry.IsDefault = TRUE THEN 
      sDefBoot = entry.Label
    END IF
  NEXT 
  iTimeOut = Conf0.SbTimeOut.Value * 10
  
  sOutput = "# LILO Configuration File \n" &
  "# Generated by the " & ClsGlobal.sDistroName & " Installer \n \n" &
  "# Begin lilo global configuration \n \n" &
  "boot = " & sTarget & "\n" &
  "default = " & sDefBoot & "\n" &
  "prompt \n" &
  "compact \n" &
  "timeout = " & iTimeOut & "\n" &
  "#\n#\n#\n" &
  "# Override dangerous defaults that require the partition table: \n" &
  "change-rules \n" &
  "reset \n"
  IF Exist(ClsGlobal.sTargetPath &/ "boot" &/ "bitmap" &/ "boot.bmp") THEN 
   sOutput = sOutput & "bitmap = /boot/bitmap/boot.bmp \n \n"
  END IF

  sOutput = sOutput & sVidText & gb.NewLine & sOsList & gb.NewLine
  
  
  
  File.Save(Temp("lilo.in"), sOutput)
  File.Save(ClsGlobal.sTargetPath &/ "etc" &/ "lilo.conf", sOutput)
  
  
  'Message(File.Load(Temp("lilo.in")))

END

PUBLIC FUNCTION get_Final_OS_list_for_lilo() AS String
  
  DIM sOutput AS String
  DIM cb AS CheckBox
  DIM tb AS TextBox
  DIM comb AS ComboBox
  DIM tl AS TextLabel
  DIM ThisEntry AS String
  DIM entry AS BootMenuEntry
  DIM Entries AS NEW Object[]
  
  FOR EACH cb IN Conf0.objMenuObjects
    entry = NEW BootMenuEntry
      entry.Enabled = cb.Value
      entry.Root = cb.Tag
        FOR EACH tl IN Conf0.objNames
          IF tl.Name = cb.Tag THEN entry.kernel = tl.tag
        NEXT 
        FOR EACH comb IN Conf0.objinitrds
          IF comb.Tag = cb.Tag THEN entry.initrd = comb.Text
        NEXT 
        FOR EACH tb IN Conf0.objappends
          IF tb.tag = cb.tag THEN entry.StartupOptions = tb.Text
        NEXT 
    Entries.Add(entry)
  NEXT 
    
    ' generate the list
    FOR EACH entry IN Entries
      IF entry.Enabled = TRUE THEN 
        ThisEntry = "# Menu entry for " & entry.Label & "\n" &
        "image = " & entry.kernel & "\n" &
        "root = " & entry.Root & "\n" &
        "label = " & entry.Label & "\n" &
        "initrd = " & entry.initrd & "\n" &
        "append = " & entry.StartupOptions & "\n" & 
        "read-only" & gb.NewLine
        sOutput = sOutput & ThisEntry
      END IF
    NEXT 
    
    RETURN sOutput
        
        
        
    
        
            
      
  
END



PUBLIC SUB SETUP_LILO_BOOT_MANAGER()
  
  DIM cbx AS CheckBox
  DIM cb AS ComboBox
  DIM tl AS TextLabel
  DIM sKernel, sInitrd, sArch, sTmpMnt, sHostPart AS String
  DIM entry AS BootMenuEntry
  
  ' find kernels and initrds, copy them to /boot on the target dir
  ' can't use /boot/tamu anymore... all has to go into /boot
    FOR EACH entry IN MdlBootMngr.objMenuEntries
      IF entry.Enabled = TRUE THEN 
        sTmpMnt = Right(entry.Root, Len(entry.Root) - Len("/dev/"))
        sHostPart = sTmpMnt
        sTmpMnt = "/mnt" &/ sTmpMnt
        
          SHELL "mount -o ro " & entry.Root & Space(1) & sTmpMnt WAIT 
          DEBUG "Importing kernel for " & entry.Label
          SHELL "cp " & sTmpMnt &/ entry.kernel & Space(1) & ClsGlobal.sTargetPath &/ entry.kernel & "-" & sHostPart WAIT 
          entry.kernel = entry.kernel & "-" & sHostPart
          SHELL "umount " & sTmpMnt WAIT 
      END IF
    NEXT 
            
  
  ' determine wether we need to update modules
  EXEC ["uname", "-r"] TO sArch
    IF Exist("/lib" &/ "modules" &/ Trim(sArch)) = FALSE THEN ' hosted install detected
      EXEC ["mkdir", "-p", "/lib" &/ "modules" &/ Trim(sArch)] WAIT 
      SHELL "mount -o bind " & ClsGlobal.sTargetPath &/ "lib/modules" &/ Trim(sArch) & Space(1) & "/lib/modules" &/ Trim(sarch) & " && depmod -aq" WAIT 
    END IF
      
  
  ' now that kernels have been copied, I need to run lilo
  ' Bind mount the target /tmp and sys dirs  now
  ' See PUBLIC SUB_PERFORM_BINDING on iVL branch
  EXEC ["mount", "-o", "bind", "/sys", ClsGlobal.sTargetPath &/ "sys"] WAIT 
  EXEC ["mount", "-o", "bind", "/proc", ClsGlobal.sTargetPath &/ "proc"] WAIT 
  EXEC ["mount", "-o", "bind", "/tmp", ClsGlobal.sTargetPath &/ "tmp"] WAIT 
  EXEC ["mount", "-o", "bind", "/dev", ClsGlobal.sTargetPath &/ "dev"] WAIT 
  
  ' now, we need to run the lilo command itself
  DEBUG "Chroot into target, load modules and execute lilo"
  'SHELL "chroot " & ClsGlobal.sTargetPath & "; sleep 1; echo \' Done chrooting\'; /sbin/depmod -aq ; lilo " WAIT 
  DEBUG "Opening chroot shell for lilo setup."
  $chroot = SHELL "chroot " & ClsGlobal.sTargetPath FOR READ WRITE 
  
  'PRINT #$chroot, "echo \"test\""
  PRINT #$chroot, "/sbin/depmod -aq"
  PRINT #$chroot, "/sbin/lilo -v"
  PRINT #$chroot, "echo \"Done\""
  
END

PUBLIC SUB Process_Read()
  
  DIM sLine AS String
  READ #LAST, sLine, -256
  PRINT sLine
  
END
PUBLIC SUB Process_Error(Errormessage AS String)

  PRINT Errormessage
  
  
END



PUBLIC SUB GENERATE_LILO_OS_LIST(sBootManager AS String) AS String

  DIM entry AS BootMenuEntry
  DIM sRet AS String
  DIM tempentry AS String
  
  IF sBootManager LIKE "lilo" THEN 
  FOR EACH entry IN MdlBootMngr.objMenuEntries
    IF entry.Enabled = TRUE THEN 
      tempentry = "# Menu entry for " & entry.sGrubLabel & "\n" &
      "image = " & Trim(entry.kernel) & "\n" &
      Space(5) & "root = " & entry.Root & "\n" &
      Space(5) & "label = " & entry.Label & "\n" &
      Space(5) & "read-only" & "\n"
      'Space(5) & "# append = " & entry.StartupOptions & "\n" & ' commented by default because this may be wrong.
      
    END IF
    sRet = sRet & tempentry
  NEXT 
  ELSE ' in the case of grub
  ' no code for this yet.
  END IF
      RETURN Trim(sRet)
      
      

END



PUBLIC SUB Display_Bootmanager_Target_Options(objCB AS ComboBox)
  
  DIM sList, sTarget, sDump AS String
  DIM sListArr AS String[]
  DIM i AS Integer
  DIM cb, cbl AS ComboBox
  
  SHELL "probedisk | grep -vi cdrom | cut -f 1 -d \'|\'" TO sList
  sList = Trim(sList)
  
  sListArr = Split(sList, "\n").Sort(gb.Ascent)
    FOR i = 0 TO sListArr.Max
    sTarget = ("MBR of") & Space(1) & Trim(sListArr[i])    
      objCB.Add(Trim(sTarget))
    NEXT 
    
    'Determine how the root partition was formatted
      SHELL "df -hT " & ClsGlobal.sTargetPath & " | tr -s \' \' | grep \"^/dev\" | cut -f 2 -d \' \'" TO sDump
      sDump = Trim(sDump)
    IF LCase(sDump) <> "xfs" THEN 
      objCB.Add(("Bootsector of") & Space(1) & ClsGlobal.sRoot)
      
    END IF      
  
END

PUBLIC FUNCTION Get_OS_Boot_Params(sOsRoot AS String) AS String
  
  DIM $kern, $initrd, $append, sDump AS String
  DIM i AS Integer
  DIM $dumparr, $linearr AS String[]
  DIM $file AS String = "/tmp/bootargs.lst"
  DIM $line AS String
  'dim sListarr as String[] = Split(Trim(File.Load("/tmp/bootargs.
  
  SHELL "cat " & $file & " | grep ^" & sOsRoot TO sDump
    sDump = Trim(sDump)
      $dumparr = Split(sDump, gb.NewLine)
      'IF NOT ($dumparr) THEN RETURN 
      IF $dumparr.Count <= 0 THEN RETURN 
      
      ' always grab the first line only for each os
        'IF NOT Trim($dumparr[0]) THEN RETURN 
      $line = Trim($dumparr[0])
        IF NOT ($line) THEN RETURN 

      $linearr = Split($line, ":")
                IF InStr($line, "append") THEN 
            $append = Right($line, Len($line) - InStr($line, "append") + 1) & "\"" ' this works for LILO booted os's only.
          ELSE 
            $append = Trim($linearr[5]) ' for grub botted os's
          END IF
        $kern = Trim($linearr[3])
        $initrd = Trim($linearr[4])
        
  
  RETURN $kern & "," & $initrd & "," & $append
        
END

PUBLIC FUNCTION CHECK_LILO_VALUES(bquiet AS Boolean) AS Integer
  
  ' will return 0 for clear
  ' 1 for error
  DIM tb, tb1, tb2 AS TextBox
  DIM cb AS CheckBox
  DIM sTag AS String = Conf0.TsOsList.Current.Text
    IF NOT (ClsGlobal.sDefBoot) THEN 
          IF bquiet = FALSE THEN 
            Message.Error(("You must select one operating system to be started by default"))
          END IF
        ' FOR EACH cb IN Conf0.objDefOs
        '   IF cb.Tag = sTag THEN 
        '     IF bquiet = FALSE THEN 
        '       Balloon.Error(("Check this box to make this your default operating system, or select another tab."), cb, cb.Left + 24)
        '       'RETURN 1
        '     END IF
        '   END IF
        ' NEXT 
        'DEBUG "No default OS selected"
        
      RETURN 1
    END IF
  IF Conf0.objNames.Count > 1 THEN 
  FOR EACH tb IN Conf0.objNames
    FOR EACH tb1 IN Conf0.objNames
      IF tb <> tb1 AND IF tb.Text = tb1.Text THEN 
        IF bquiet = FALSE THEN Message.Error(("Found duplicate operating system names. Please use unique labels for each menu entry"))
          FOR EACH tb2 IN Conf0.objNames
            IF tb2.Tag = sTag THEN 
              IF bquiet = FALSE THEN Balloon.Error(("Check these boxes to make sure they have unique names"), tb2, tb2.Left + 24)
            END IF
          NEXT 
        RETURN 1
      END IF
    NEXT 
  NEXT 
END IF
    RETURN 0
  
END

PUBLIC SUB CREATE_MENU_ENTRY_OBJECTS()
  
  DIM sRawList, sRawEntry, sRawLine, sOptions AS String[]
  
  DIM sDump AS String
  DIM i, ii AS Integer
  DIM entry AS BootMenuEntry
  
  
  SHELL "/bin/os-prober" TO sDump
  sDump = Trim(sDump)
  sRawList = Split(sDump, gb.NewLine)
  
  FOR i = 0 TO sRawList.Max
    sRawLine = Split(Trim(sRawList[i]), ":")
      IF NOT (sRawLine) THEN CONTINUE 
      entry = NEW BootMenuEntry
      entry.Root = sRawLine[0]
      entry.sLIloLabel = sRawLine[2]
      entry.sGrubLabel = sRawLine[1]
      entry.osType = sRawLine[sRawLine.Max]
      entry.Label = entry.sLIloLabel
      ' now we try to find out details about this linux
      IF sRawLine[3] LIKE "linux" THEN 
        SHELL "/bin/linux-boot-prober " & entry.Root TO sDump
          IF Trim(sDump) THEN 
            sOptions = Split(Trim(sDump), ":")
            entry.kernel = sOptions[3]
            entry.initrd = sOptions[4]
            entry.StartupOptions = Replace(sOptions[5], "append", "")
          END IF
          
      END IF
      ME.objMenuEntries.Add(entry)
    NEXT

  
END

