' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 
PUBLIC SUB GO_WITH_SELECTED(sDev AS String, sISONAME AS String) ' this will mount the drive and display the license agreement
  
  DIM sPathToLic AS String = ClsGlobal.sSourceMnt &/ "COPYING"
  DIM sAddy AS String = Right(sDev, Len(sDev) - RInStr(sDev, "/"))
   
  
  IF sISONAME OR sISONAME <> "" THEN 
    'SHELL "sudo mount " & sDev & " /mnt/loop" WAIT ' will switch places here .. the device will mount to loop and the iso will mount to the mount point
    SHELL "mkdir -p /mnt" &/ sAddy & " && mount " & sDev & Space(1) & "/mnt" &/ sAddy WAIT 
    SHELL "mount -o loop /mnt" &/ sAddy &/ sISONAME & Space(1) & ClsGlobal.sSourceMnt WAIT 
      
    'SHELL "sudo umount /mnt/loop" WAIT 
  ELSE 
         
    SHELL "mount " & sDev & Space(1) & ClsGlobal.sSourceMnt & " 2>/root/err" & " >/root/log" WAIT 
  END IF
  
  ' display the license agreement text
'  FrmLicense.taLicense.Text = SConv(File.Load(sPathToLic))
  
  ' This will also set the default variables for distro name and version to clsglobal
    MdlCore.SET_DECISSION(ClsGlobal.sSourceMnt)
      ' save the credits file to temp
      File.Save(Temp$("Credits"), DConv(File.Load(ClsGlobal.sSourceMnt &/ "CREDIT")))
  

END
 
 
 PUBLIC FUNCTION CHECK_IF_REBOOT_NEEDED() AS Boolean
 
 ' KNOWN BUG:
 ' This will make the user restart if there are FAT* partitions anywhere on the box
 ' even if that drive was not modified
 ' END OF BUG -- FIX SOON
 
 DIM sFATList AS String
 DIM sFAT32List AS String
 
 SHELL "probepart | grep -e \"^/dev.*FAT32$\" | sed \'s/\\*/ /\' | grep -e \"/dev\"" TO sFAT32List
 SHELL "probepart | grep -e \"^/dev.*FAT$\" | sed \'s/\\*/ /\'|grep -e \" /dev\"" TO sFATList
 
 sFAT32List = Trim(sFAT32List)
 sFATList = Trim(sFATList)
 
 IF sFAT32List <> "" THEN 
  RETURN TRUE ' reboot needed
 ELSE IF sFATList <> "" THEN 
  RETURN TRUE ' reboot needed
 ELSE 
  RETURN FALSE ' no reboot needed
 END IF
 
    
END

PUBLIC FUNCTION FORMAT_SELECTED_PARTITIONS() AS Integer
  
  'DIM hproc AS Process
  DIM sDump AS String


              
    
    SHELL "mkfs." & LCase(ClsPartSel.fRoot) & " || echo \'ERROR\'" TO sDump
      
            GOTO CHECK_OUTPUT
 
 
 IF ClsPartSel.sHome AND ClsPartSel.fhome <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fhome) & " || echo \'ERROR\'" TO sDump
    
    GOTO CHECK_OUTPUT
  END IF
  
 
 
 IF ClsPartSel.sOpt AND ClsPartSel.fOpt <> "Do not format" THEN 
 sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fOpt) & " || echo \'ERROR\'" TO sDump
     
        GOTO CHECK_OUTPUT
 END IF
 
 IF ClsPartSel.sUsr AND ClsPartSel.fUsr <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fUsr) & " || echo \'ERROR\'" TO sDump
    
      GOTO CHECK_OUTPUT
 END IF
 
 IF ClsPartSel.sVar AND ClsPartSel.fVar <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fVar) & " || echo \'ERROR\'" TO sDump
    
    GOTO CHECK_OUTPUT
  END IF
  
  IF ClsPartSel.sTmp AND ClsPartSel.fTmp <> "Do not format" THEN 
    sDump = ""
       SHELL "mkfs." & LCase(ClsPartSel.fTmp) & " || echo \'FAILED\'" TO sDump
        
          GOTO CHECK_OUTPUT
  END IF
  
  
  
CHECK_OUTPUT:
 IF InStr(sDump, "ERROR") = TRUE THEN 
                RETURN 1 ' not good... stop right there
              ELSE 
                RETURN 0
              END IF  
  
END



PUBLIC SUB SHOW_PROGRESS_CONTROLS()
  
  WITH FrmInstallSys
  .tlCurrStepLbl.Visible = TRUE
    .pbInstallProg.Visible = TRUE
    .tlCurrPkg2.Visible = TRUE
    .pbInstallProg2.Visible = TRUE
  END WITH 
  
END

PUBLIC FUNCTION UPDATE_OVERALL_PROGRESS(iTotalPkgs AS Integer, iCurrPkg AS Integer) AS Float
  DIM fRet AS Float
  DIM fcur AS Float
  DIM fpkg AS Float = 0.4
  DIM fbulk AS Float = 0.6
  DIM iCPkg AS Integer
   IF iTotalPkgs = 0 THEN 
     iTotalPkgs = 30
   ENDIF 

  'fRet = iCurrPkg / iTotalPkgs
  'fRet = Round(fRet, -2)
  IF iCurrPkg <= ClsGlobal.iBulkCnt THEN 
    fcur = fbulk / ClsGlobal.iBulkCnt
    fRet = iCurrPkg * fcur
    fRet = Round(fRet, -2)
  ELSE 
    fcur = fpkg / ClsGlobal.iPkgCnt
    iCPkg = iCurrPkg - ClsGlobal.iBulkCnt
    fRet = iCPkg * fcur
    fRet = Round(fRet, -2)
    fRet = fRet + fbulk
  ENDIF 
  RETURN fRet
  
END



PUBLIC FUNCTION CALCULATE_PACKAGE_COUNT(bCustom AS Boolean) AS Integer

  DIM sOutput AS String
  DIM sOutArr AS String[]
  DIM cb AS CheckBox
  DIM sDump AS String
  DIM sTotalList AS String
  DIM i, ii AS Integer
  DIM irs AS Integer
  DIM sList AS String[]
  
  ' let's get a package count
  IF bCustom = FALSE THEN 'DOING A FULL INSTALL
    'find bulks
    SHELL "find " & ClsGlobal.sSourceMnt & "/veclinux -name \"*.tlz\"|wc -l" TO ClsGlobal.iBulkCnt
    'find packages
    SHELL "find " & ClsGlobal.sSourceMnt & "/packages -name  \"*.tlz\"|wc -l" TO ClsGlobal.iPkgCnt
    ClsGlobal.iPkgCnt = ClsGlobal.iPkgCnt + 3 
    ClsGlobal.iPkgTot = ClsGlobal.iBulkCnt + ClsGlobal.iPkgCnt
    PRINT ClsGlobal.iPkgTot
  ELSE ' GOING FOR CUSTOM INSTALL
    PRINT ("Calculating package count ... Please wait")
    SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF" & " | grep ^BULK | grep required" TO sOutput
    sOutput = Trim(sOutput)
    IF InStr(sOutput, "\n") > 0 THEN 
      sOutArr = Split(sOutput, "\n")
      i = i + sOutArr.Count
    ELSE 
      i = i + 1
    END IF
    'add bulks to ClsGlobal.iBulkCnt 
    ClsGlobal.iBulkCnt = i
    'count required packages in            
    sOutArr.Clear
    sOutput = ""
    SHELL "ls -m " & ClsGlobal.sSourceMnt &/ "packages" &/ "required" &/ "*.t?z" TO sOutput
    sOutput = Trim(sOutput)
    sOutArr = Split(sOutput, ",")
    i = i + sOutArr.Count
    'add pkgs TO ClsGlobal.iPkgCnt 
    ClsGlobal.iPkgCnt = sOutArr.Count
    'Count CONF packages in
    sOutArr.Clear
    sOutput = ""
    SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF" & " | grep ^CONF" TO sOutput
    sOutput = Trim(sOutput)
    IF InStr(sOutput, "\n") > 0 THEN 
      sOutArr = Split(sOutput, "\n")
      i = i + sOutArr.Count
      'add config bulks to ClsGlobal.iBulkCnt 
      ClsGlobal.iBulkCnt = ClsGlobal.iBulkCnt + sOutArr.Count
    ELSE 
      i = i + 1 
      'add config bulks to ClsGlobal.iPkgCnt cause they are small and at the end 
      ClsGlobal.iPkgCnt = ClsGlobal.iPkgCnt + 1
    END IF
    'Count user-selected bulks
    REPEAT 
      IF FrmPkgSel.scrlInstallOpts[ii, 0].Picture = FrmPkgSel.pyes THEN INC irs
      INC ii
      UNTIL ii = FrmPkgSel.scrlInstallOpts.Rows.Count
    i = i + irs
    'add bulks to ClsGlobal.iBulkCnt 
    ClsGlobal.iBulkCnt = ClsGlobal.iBulkCnt + irs
    ' now do the optional packages
    irs = 0 ' reset the count
    REPEAT 
      IF FrmUsrPkgSel.GridView1[ii, 0].Picture = FrmUsrPkgSel.pYes THEN 
        INC irs
      END IF
      INC ii
      UNTIL ii = FrmUsrPkgSel.GridView1.Rows.Count
    i = i + irs ' the count to the total
    'add pkgs TO ClsGlobal.iPkgCnt 
    ClsGlobal.iPkgCnt = ClsGlobal.iPkgCnt + irs + 3
    ClsGlobal.iPkgTot = i + 3
  END IF
  PRINT ("Total bulks to be installed = ") & ClsGlobal.iBulkCnt
  ClsGlobal.fPbInc = 0.6 / ClsGlobal.iBulkCnt
  PRINT "The total progrssbar will work in increments of " & ClsGlobal.fPbInc & " on every bulk installed"
  PRINT ("Total pkgs to be installed = ") & ClsGlobal.iPkgCnt
  ClsGlobal.fPbInc = 0.4 / ClsGlobal.iPkgCnt
  PRINT "The total progrssbar will work in increments of " & ClsGlobal.fPbInc & " on every pkg installed" 
  RETURN ClsGlobal.iPkgTot
END





PUBLIC SUB RUN_CREDITS()
  
  DIM sCreditFile AS String = DConv(File.Load(Temp("Credits")))  
  DIM tlOutput AS TextLabel = FrmInstallSys.tlCredits
  DIM sFile AS String[] = Split(sCreditFile, "\n")
  DIM i AS Integer
  tlOutput.Text = ""

  FOR i = 0 TO sFile.count - 1
      IF Left(Trim(sFile[i]), Len("M0E-lnx")) = "M0E-lnx" THEN 
              sFile[i] = "M0E-lnx  [ vpackager, vasmCC, GUI installer ]"
      ELSE IF Left(Trim(sFile[i]), Len("Uelsk8s")) = "Uelsk8s" THEN 
          sFile[i] = "Uelks8s [ vlthemeswitch, ISO Master, Gui Installer ]"
      ELSE 
        sFile[i] = sFile[i]
      END IF
      'tlOutput.text = tlOutput.text & "<br>" & sFile[i]
      'tlOutput.Adjust
    tlOutput.Text = tlOutput.Text & " ~ " & sFile[i]
'    tlOutput.Text = sFile[i]
    
  NEXT 
  tlOutput.Width = MdlObjSizer.get_object_width(tlOutput.Text) + 24
  WAIT 
  FrmInstallSys.tmCredits.Enabled = TRUE
    
END

PUBLIC SUB BEGIN_INSTALLATION()
    DIM sCreditList AS String = File.Load(ClsGlobal.sSourceMnt &/ "CREDIT")
    DIM sCredit AS String[] = Split(sCreditList, "\n")
    DIM i AS Integer
    
        FrmCredits.TextLabel1.text = "<b>" & ("BROUGHT TO YOU BY") & "</b><br><br><br><br><br>" '& sCreditList
          FOR i = 0 TO sCredit.count - 1
              IF InStr(sCredit[i], "M0E-lnx") THEN 
                sCredit[i] = "<b>" & "M0E-lnx" & "</b><br>" & "[ GUI Installer, vpackager, VASMCC ]"
              ELSE IF InStr(sCredit[i], "Uelsk8s") THEN 
                sCredit[i] = "<b>" & "Uelsk8s" & "</b><br>" & "[ GUI Installer, ISO Master, vlthemeswitch ]"
              ELSE IF Left(sCredit[i], Len("Lost")) = "Lost" THEN 
                sCredit[i] = "Lost-n-LovinLinux" ' " Lost " & " & " & " LovinLinux ""
              END IF
            FrmCredits.TextLabel1.text = FrmCredits.TextLabel1.text & sCredit[i] & "<br><br><br>"
          NEXT 
        
  
  
  
  MdlCore.LOCK_GUI()
    FrmInstallSys.tlCurrPkg.text = ("Activating swap space")
  MdlInstallSys.ACTIVATE_SWAP_SPACE()
    FrmInstallSys.tlCurrPkg.text = ("Preparing filesystems")
  MdlPartFrmt.PREPARE_ALL_PARTITIONS() ' This will start the install process
    
  
END

PUBLIC FUNCTION SCAN_HOME_DIRS(sHomePartition AS String) AS String
  
  DIM sDump AS String
    SHELL "ls " & sHomePartition & " | grep -v ftp | grep -v lost+found | grep -v .*" TO sDump
    
    sDump = Trim(sDump)
    RETURN sDump
  
END


