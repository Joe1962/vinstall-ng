' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 
PUBLIC SUB GO_WITH_SELECTED(sDev AS String, sISONAME AS String) ' this will mount the drive and display the license agreement
  
  DIM sPathToLic AS String = ClsGlobal.sSourceMnt &/ "COPYING"
  DIM sAddy AS String = Right(sDev, Len(sDev) - RInStr(sDev, "/"))
   
  
  IF sISONAME OR sISONAME <> "" THEN 
    'SHELL "sudo mount " & sDev & " /mnt/loop" WAIT ' will switch places here .. the device will mount to loop and the iso will mount to the mount point
    SHELL "mkdir -p /mnt" &/ sAddy & " && mount " & sDev & Space(1) & "/mnt" &/ sAddy WAIT 
    SHELL "mount -o loop /mnt" &/ sAddy &/ sISONAME & Space(1) & ClsGlobal.sSourceMnt WAIT 
      
    'SHELL "sudo umount /mnt/loop" WAIT 
  ELSE 
         
    SHELL "mount " & sDev & Space(1) & ClsGlobal.sSourceMnt & " 2>/root/err" & " >/root/log" WAIT 
  END IF
  
  ' display the license agreement text
'  FrmLicense.taLicense.Text = SConv(File.Load(sPathToLic))
  
  ' This will also set the default variables for distro name and version to clsglobal
    MdlCore.SET_DECISSION(ClsGlobal.sSourceMnt)
  

END
 
 
 PUBLIC FUNCTION CHECK_IF_REBOOT_NEEDED() AS Boolean
 
 ' KNOWN BUG:
 ' This will make the user restart if there are FAT* partitions anywhere on the box
 ' even if that drive was not modified
 ' END OF BUG -- FIX SOON
 
 DIM sFATList AS String
 DIM sFAT32List AS String
 
 SHELL "probepart | grep -e \"^/dev.*FAT32$\" | sed \'s/\\*/ /\'" TO sFAT32List
 SHELL "probepart | grep -e \"^/dev.*FAT$\" | sed \'s/\\*/ /\'" TO sFATList
 
 sFAT32List = Trim(sFAT32List)
 sFATList = Trim(sFATList)
 
 IF sFAT32List <> "" THEN 
  RETURN TRUE ' reboot needed
 ELSE IF sFATList <> "" THEN 
  RETURN TRUE ' reboot needed
 ELSE 
  RETURN FALSE ' no reboot needed
 END IF
 
    
END

PUBLIC FUNCTION FORMAT_SELECTED_PARTITIONS() AS Integer
  
  'DIM hproc AS Process
  DIM sDump AS String


              
    
    SHELL "mkfs." & LCase(ClsPartSel.fRoot) & " || echo \'ERROR\'" TO sDump
      
            GOTO CHECK_OUTPUT
 
 
 IF ClsPartSel.sHome AND ClsPartSel.fhome <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fhome) & " || echo \'ERROR\'" TO sDump
    
    GOTO CHECK_OUTPUT
  END IF
  
 
 
 IF ClsPartSel.sOpt AND ClsPartSel.fOpt <> "Do not format" THEN 
 sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fOpt) & " || echo \'ERROR\'" TO sDump
     
        GOTO CHECK_OUTPUT
 END IF
 
 IF ClsPartSel.sUsr AND ClsPartSel.fUsr <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fUsr) & " || echo \'ERROR\'" TO sDump
    
      GOTO CHECK_OUTPUT
 END IF
 
 IF ClsPartSel.sVar AND ClsPartSel.fVar <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fVar) & " || echo \'ERROR\'" TO sDump
    
    GOTO CHECK_OUTPUT
  END IF
  
  IF ClsPartSel.sTmp AND ClsPartSel.fTmp <> "Do not format" THEN 
    sDump = ""
       SHELL "mkfs." & LCase(ClsPartSel.fTmp) & " || echo \'FAILED\'" TO sDump
        
          GOTO CHECK_OUTPUT
  END IF
  
  
  
CHECK_OUTPUT:
 IF InStr(sDump, "ERROR") = TRUE THEN 
                RETURN 1 ' not good... stop right there
              ELSE 
                RETURN 0
              END IF  
  
END


PUBLIC SUB MOUNT_DEFINED_PARTITIONS()
  
  ' this is where we need to set the mount target
  ClsGlobal.sTargetMnt = "/mnt/target"
    IF Exist(ClsGlobal.sTargetMnt) = FALSE THEN 
      TRY MKDIR ClsGlobal.sTargetMnt
    END IF
    
    SHELL "umount " & ClsGlobal.sTargetMnt WAIT 'clear the mount point
    
    SHELL "mount " & ClsPartSel.sRoot & Space(1) & ClsGlobal.sTargetMnt & Space(1) & " -t " & ClsPartSel.fRoot WAIT  'moun the root partition first
    IF ClsPartSel.sHome THEN 
        SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "home" WAIT 
      SHELL "mount " & ClsPartSel.sHome & Space(1) & ClsGlobal.sTargetMnt &/ "home -t " & ClsPartSel.fhome WAIT 'mount the home partition if defined
      
    END IF
    IF ClsPartSel.sUsr THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "usr" WAIT 
      SHELL "mount " & ClsPartSel.sUsr & Space(1) & ClsGlobal.sTargetMnt &/ "usr -t" & ClsPartSel.fUsr WAIT ' mount the user partition
    END IF
    IF ClsPartSel.sOpt THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "opt" WAIT 
      SHELL "mount " & ClsPartSel.sOpt & Space(1) & ClsGlobal.sTargetMnt &/ "opt -t " & ClsPartSel.fOpt WAIT 'mount the opt partitiong
    END IF
    IF ClsPartSel.sVar THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "var" WAIT 
      SHELL "mount " & ClsPartSel.sVar & Space(1) & ClsGlobal.sTargetMnt &/ "var -t " & ClsPartSel.fVar WAIT 
    END IF
    IF ClsPartSel.sTmp THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "tmp" WAIT 
      SHELL "mount " & ClsPartSel.sTmp & Space(1) & ClsGlobal.sTargetMnt &/ "tmp -t " & ClsPartSel.fTmp WAIT 
    END IF
      
    ' see if there is a swap partition and use it
      IF ClsPartSel.sSwap THEN 
        SHELL "swapon -a " WAIT 
      END IF
    
    'WRITE THE NEW FSTAB NOW, RIGHT BEFORE INSTALLING PACKAGES.
    
    ME.WRITE_NEW_FSTAB()
    
  
  
END



PUBLIC FUNCTION WRITE_NEW_FSTAB()
  
  DIM sEntry AS String
  DIM sPartition AS String
  DIM sMountPoint AS String
  DIM sMntOpts AS String
  
  DIM sFstab AS String
  
  sFstab = "# /etc/fstab: static file system information.\n" &
  "#\n" &
"#The following is an example.Please see fstab(5) for further details.\n" &
"#Please refer to mount(1) for a complete description OF mount options.\n" &
"#\n" &
"#Format:\n" &
"# < file system > < mount point > < type > < options > < dump > < pass >\n" &
"#\n" &
"#dump(8)uses the < dump > field to determine which file systems need \n" &
"# to be dumped.fsck(8)uses the < pass > column TO determine which file \n" &
"#systems need TO be checked - - the root file system should have a 1 in \n" &
"#this field, other file systems a 2, AND any file systems that should \n" &
"#not be checked(such AS MS - initrd / mnt OR NFS file systems)a 0.\n\n\n" &
"#The Linux partitions\n"

sFstab = sFstab & gb.NewLine & 
ClsPartSel.sRoot & " / " & LCase(ClsPartSel.fRoot) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fRoot)) & " 0 1" & gb.NewLine
IF ClsPartSel.sHome THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sHome & " /home " & LCase(ClsPartSel.fhome) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fhome)) & " 0 2"
END IF
IF ClsPartSel.sUsr THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sUsr & " /usr " & LCase(ClsPartSel.fUsr) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fUsr)) & " 0 2 "
END IF
IF ClsPartSel.sOpt THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sopt & " /opt " & LCase(ClsPartSel.fOpt) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fOpt)) & " 0 2 "
END IF
IF ClsPartSel.sVar THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sVar & " /var " & LCase(ClsPartSel.fVar) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fVar)) & " 0 2 "
END IF
IF ClsPartSel.sTmp THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sTmp & " /tmp " & LCase(ClsPartSel.fTmp) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fTmp)) & " 0 2 "
END IF

sFstab = sFstab & "\n\n" &
"# Shared Windows/Linux partition" &
"#/dev/hda1   /mnt/dos  msdos  umask=0   0  0 \n" &
"#/dev/hda1   /mnt/win  vfat   fmask=111,dmask=0,quiet,shortname=mixed,user  0  0 \n" &
"#/dev/hda1   /mnt/win  ntfs   umask=0   0  0\n" &
"# Floppy disks \n" &
"# The 'noauto' option indicates that the file system should not be mounted \n" &
"# with 'mount -a' 'user' indicates that normal users are allowed to mount \n" &
"# the file system. \n" &
"/dev/fd0   /mnt/floppy  auto  defaults,noauto,user  0 0 \n" &
"#/dev/fd1  /mnt/floppy  auto  defaults,noauto,user  0 0 \n\n" &
"# If you have a ls-120 floppy drive, it could be on /dev/hda b c d etc.\n" &
"#/dev/hdd  /mnt/ls120  auto  defaults,noauto,user  0 0 \n\n" &
"# CDROM, CDWRITER, DVD \n" &
"/dev/cdrom    /media/cdrom  iso9660  defaults,noauto,ro,user  0 0 \n" &
"#/dev/cdwriter /media/cdwriter  iso9660  defaults,noauto,rw,user  0 0 \n" &
"#/dev/dvd      /media/dvd   auto  defaults,noauto,ro,user  0 0\n\n" &
"# NFS file systems:\n" &
"#linux01.gwdg.de:/suse/6.3/i386.de  /mnt/nfs  nfs  defaults  0 0\n\n" &
"# proc file system:\n" &
"proc  /proc  proc  defaults  0 0\n\n" &
"# Unix98 devpts filesystem: \n" &
"none  /dev/pts  devpts  gid=5,mode=666  0 0\n\n" &
"# Shared memory filesystem: \n" &
"tmpfs   /dev/shm    tmpfs defaults 0  0 \n\n" &
"# Basic USB filesystem\n" &
"sysfs  /sys  sysfs  defaults  0 0\n" &
"usbfs /proc/bus/usb usbfs rw,devmode=0666 0 0\n\n" &
"# example of a VFAT USB pendrive\n" &
"#/dev/sda1  /mnt/pendrive vfat   fmask=111,dmask=0,noauto,user,quiet,shortname=mixed 0 0\n\n" &
"# Swap partitions\n" &
"# The 'sw' option means auto activating with 'swapon -a'.\n"
IF ClsPartSel.sSwap THEN 
  sFstab = sFstab & gb.NewLine &
   ClsPartSel.sSwap & Space(5) & "none" & Space(5) & "swap" & Space(5) & "sw" & Space(5) & "0" & Space(5) & "0"
END IF
' Wheewww!... that's the whole fstab there... Please fix the win partitions






  
  
  
  
END 
PUBLIC FUNCTION fS_oPTIONS(sType AS String) AS String
  
    DIM sMntOpts AS String
    
    SELECT CASE LCase(sType)
      CASE "reiserfs"
        sMntOpts = "noatime"
      CASE "vfat"
        sMntOpts = "fmask=111,dmask=0,gid=users,shortname=mixed,quiet,user"
      CASE "ntfs"
        sMntOpts = "umask=0,gid=users,user"
      CASE "ext2", "ext3"
        sMntOpts = "defaults"
      CASE ELSE 
        sMntOpts = "defaults"
    END SELECT 
    
    RETURN sMntOpts
  
  
END



