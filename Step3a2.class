' Gambas class file
'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

PRIVATE lLargest AS Long
PRIVATE lTotalRam AS Long
PRIVATE lNeededSwap AS Long
PRIVATE sLargestDev AS String
PRIVATE objTargetOptions AS Object[]

PUBLIC SUB Form_Open()

  ME.tlbanner.Text = "<h2>" & ("Install") & Space(1) & ClsGlobal.sDistroName & Space(1) & ("to free space on disk") & "</H2>"
  ME.MovieBox1.Path = "images/throbber.gif"
  ME.MovieBox1.Playing = FALSE
  'objTargetOptions = NEW Object[]
  
  'ME.LIST_FREE_SPACE()

END

PUBLIC SUB LIST_FREE_SPACE()
  
  DIM sDiscs, sLine AS String[]
  DIM sDisc, sDump, sFreeDump AS String
  DIM lFreeSpace AS Float ' free space in KB
  DIM lTotalFreeKb, lFreeBegin, lFreeEnd AS Long
  DIM sFreeBeinRaw, sFreeEndRaw AS String
  DIM i AS Integer
  'DIM lTotalRam AS Long
  DIM rb AS RadioButton
  
  ME.tlSelAutoTarget.Text = ("Searching for unused space on your hard drive... please wait")

  'objTargetOptions = NEW Object[]

  PRINT " -*- Determing total RAM available ..."
    SHELL "free | grep -i \"^Mem\" | tr -s \' \',\"\" | cut -f 2 -d \' \'" TO sDump
      lTotalRam = Trim(sDump)
      IF lTotalRam < 512000 THEN 
        lNeededSwap = lTotalRam * 2
      ELSE 
        lNeededSwap = lTotalRam
      END IF
      'Message(lNeededSwap)
    PRINT " -+- Total RAM Available : " & lTotalRam & " KB"
    PRINT " -*- Calculating available free space"
  
    SHELL "probedisk | grep -v cdrom | cut -f 1 -d \'|\'" TO sDump
      sDump = Trim(sDump)
        IF NOT sDump THEN  ' EXIT IF NO HARD DRIVES ARE FOUND
          Message.Error(("No hard disks found on your system. Please select") & "<br>" &
          ("Another partitioning option"))
          RETURN 
        END IF
        
    sDiscs = Split(sDump, "\n")
      FOR i = 0 TO sDiscs.Max

        sDisc = Trim(sDiscs[i])
          ' get the free space from parted
          SHELL "parted " & Trim(sDisc) & " print free | grep -i \"free space\" | tr -s \' \',\"\"" TO sDump
            sDump = Trim(sDump)
              IF NOT sDump THEN CONTINUE 
            ' free space should be on the 3rd column, but it start with a blank space, so it will be 4th
            sLine = Split(sDump, Space(1))
              sFreeDump = Trim(sLine[2])
              sFreeBeinRaw = Trim(sLine[0]) ' Beginning of free space
              sFreeEndRaw = Trim(sLine[1]) ' End of free space
              lFreeSpace = Left(sFreeDump, Len(sFreeDump) - 2) ' take away the KB,MB,GB,TB off the result
                ' fix the units by converting everything to kb
                lTotalFreeKb = ME.ConvertToKb(sFreeDump)
'              Message("Free space on " & sDisc & " begins at " & ME.ConvertToKb(sFreeBeinRaw) & "kb and ends at " & ME.ConvertToKb(sFreeEndRaw) & " kb")
              
              'Message(sFreeDump)
                IF lTotalFreeKb > lLargest THEN 
                   lLargest = lTotalFreeKb
                   sLargestDev = Trim(sDisc)
                    FOR EACH RadioButton1 IN objTargetOptions
                      RadioButton1.Text = Replace(RadioButton1.Text, ("(Recomended)"), "")
                    NEXT 
                END IF
                    PRINT " -+- Found " & lTotalFreeKb & " KB in " & sDisc
                    
                ME.RadioButton1 = NEW RadioButton(ME.hpanel3) AS "TargetOptions"
                  IF (lTotalFreeKb - lNeededSwap) > 4194304 THEN 
                    WITH ME.RadioButton1
                      .Enabled = TRUE
                        IF sLargestDev = sDisc THEN 
                          .Text = sDisc & Space(1) & "-" & Space(1) & lTotalFreeKb & Space(1) & "Kb" & Space(1) & ("of free space") & Space(1) & ("(Recomended)")
                          .Value = TRUE
                        ELSE 
                          .Text = sDisc & Space(1) & "-" & Space(1) & lTotalFreeKb & Space(1) & "Kb" & Space(1) & ("of free space")
                        END IF
                      .Expand = TRUE
                      .Height = 21
                      .Tag = sDisc
                    END WITH 
                  ELSE 
                    WITH ME.RadioButton1
                      .Enabled = FALSE
                      .Text = sDisc & Space(1) & "-" & Space(1) & lTotalFreeKb & Space(1) & "Kb" & Space(1) & ("of free space")
                      .Expand = TRUE
                      .Height = 21
                      .Tag = sDisc
                    END WITH 
                  END IF
                  IF objTargetOptions.Find(ME.RadioButton1) = -1 THEN objTargetOptions.Add(ME.RadioButton1)
                  ME.HBox2 = NEW HBox(ME.HPanel3) AS "spacers"
                    WITH ME.HBox2
                      .Height = 12
                      .Expand = TRUE
                      .Tag = sDisc
                    END WITH  

  
'NOTES
' root:# parted /dev/hda --script "mkpartfs primary linux-swap -512kb -1kb" ' SAMPLE PARTED LINE
' if ram < 512MB then swap = ram*2
' default / fs = reiserfs





    NEXT 
        
    'Message("Largest unused area found: " & sLargestDev & " with " & lLargest & " kb of unused space")
    PRINT " -++- Largest unused area found in :" & sLargestDev & " totaling " & lLargest & " kb of free space"
  
  ME.tlSelAutoTarget.Text = ("Select the location on your hard drive where you would like to install") & Space(1) & ClsGlobal.sDistroName
  
END





PUBLIC SUB ConvertToKb(sRawString AS String) AS Long
  
  DIM fSize AS Float
  DIM sTrimmed AS Float = Left(sRawString, Len(sRawString) - 2)
  DIM sTotal AS Long
    
    IF Right(sRawString, 2) = "MB" THEN 
      fSize = sTrimmed
      sTotal = fSize * 1024
    ELSE IF Right(sRawString, 2) = "GB" THEN 
      fSize = sTrimmed
      sTotal = (fSize * 1024) * 1024
    ELSE IF Right(sRawString, 2) = "KB" OR Right(sRawString, 2) = "kB" THEN 
      fSize = sTrimmed
      sTotal = fSize
    ELSE IF Right(sRawString, 1) = "B"
      fSize = sTrimmed
      sTotal = fSize
    END IF
    
  RETURN sTotal
    
      
  
  
END


PUBLIC SUB PERFORM_PARTITIONING()
  
  DIM i, iLastPartNo AS Integer
  DIM sDrive, sPartedRes, sFreeStart, sFreeEnd, sFreeSize, sDump AS String
  DIM sOutLine, sDumparr AS String[]
  DIM lFreeKB, lFreeStart, lFreeEnd AS Long
  DIM sRootPart, sSwapPart AS String
  DIM sPart, sNum AS String
  
      
    ME.HPanel3.Visible = FALSE
    ME.HPanel4.Visible = TRUE
    ME.MovieBox1.Playing = TRUE
    ME.tlSelAutoTarget.Text = ("Please wait while your hard drive is being partitioned")
    
      FOR EACH RadioButton1 IN objTargetOptions
        IF RadioButton1.Value = TRUE THEN 
          IF RadioButton1.Enabled = TRUE THEN 
          sDrive = RadioButton1.Tag
          END IF
        END IF
      NEXT 
      'Message(sDrive)
      WAIT 1
      IF NOT sdrive THEN 
        Message.Error(("Unable to find enough un-used space to perform auto-partition.") & gb.NewLine &
        ("Please consider using a different partitioning option."))
          ME.MovieBox1.Playing = FALSE
          ME.tlSelAutoTarget.Text = ("Unable to find enough un-used space to perform auto-partition. Please consider using a different partitioning option.")
          ME.MovieBox1.Enabled = FALSE
        RETURN 
      END IF
    ' read from parted again
    SHELL "parted " & Trim(sDrive) & " unit kb print free | grep -i \"free space\" | tr -s \' \',\"\" | cut -f 2-4 -d \' \'" TO sPartedRes
      'Message(sPartedRes)
      sPartedRes = Trim(sPartedRes) ' | START | | END | | SIZE |
        sOutLine = Split(sPartedRes, Space(1))
          sFreeStart = sOutLine[0]
          sFreeEnd = sOutLine[1] 
          sFreeSize = sOutLine[2]
      ' I need to know where the free space stars and ends to do this.
      lFreeKB = ME.ConvertToKb(sFreeSize)
      lFreeStart = ME.ConvertToKb(sFreeStart)
      lFreeEnd = ME.ConvertToKb(sFreeEnd)
      ' keep in mind that only partitions 1-4 can be primary... everything else must be extended
      ' I need to use probepart to see the number of the last partition present in the drive
      ' And figure out the partition numbers for the future partitions.
      SHELL "probepart | grep \"^" & Trim(sDrive) & "\" | tr -s \' \',\"\" | cut -f 1 -d \' \'" TO sDump
        'Message(sDump)
        sDump = Trim(sDump)
          IF NOT sDump THEN 'The entire disc IS not partitioned. 'Message("No partitions found ont his disk")
          iLastPartNo = 0
              ' create new partitions on raw space.
              ' root:# parted /dev/hda --script "mkpartfs primary linux-swap -512kb -1kb" ' SAMPLE PARTED LINE
            
              SHELL "parted " & Trim(sDrive) & " -s \"mkpart primary reiserfs 0kb -" & lNeededSwap & "kb\"" WAIT ' partition 1
              'WAIT 1
          SHELL "probepart | grep -i \"linux swap\"| cut -f 1 -d \' \'" TO sDump
                      sDump = Trim(sDump)   ' this is possibly an array
                        IF sDump THEN 
                          sDumparr = Split(sDump, "\n")
                          PRINT " ---+ Use existing swap partition -> " & sDumparr[0]
                          sSwapPart = Trim(sDumparr[0])
                        
                            
                        ELSE 
                            SHELL "parted " & Trim(sDrive) & " -s \"mkpart primary linux-swap -" & lNeededSwap & "kb -1kb\"" WAIT ' partition 2
                            SHELL "mkswap " & Trim(sDrive) & (iLastPartNo + 2) WAIT ' make the swap partition
                            EXEC ["swapon", Trim(sDrive) & (iLastPartNo + 2)] WAIT 
                              sSwapPart = Trim(sdrive) & (iLastPartNo + 2)      
                        END IF
          sRootPart = Trim(sdrive) & (iLastPartNo + 1)
          
                ' Ready to start setting defined target partitions.
                '###################################################################################################################
              
          ELSE ' There is already some partitions in the disc.... I need to know which numbers to use.
              sDump = Replace(sDump, sDrive, "")
              sDumparr = Split(sDump, "\n")
                 FOR i = 0 TO sDumparr.Max
                   'Message(sDumparr[i])
                   iLastPartNo = Trim(sDumparr[i])
                 NEXT 
                  ' now that we got the last partition number, we can start creating our partitions.
                        ' if there is room for primary partitions, make them
                      IF iLastPartNo <= 2 THEN 
                         'Message(lFreeEnd - lNeededSwap)
                         'Message(lFreeStart)
                          PRINT "start -> " & lFreeStart
                          PRINT "end -> " & lFreeEnd
                          PRINT "Needed swap -> " & lNeededSwap
                          PRINT "Beginning of swap area -> " & (lFreeEnd - lNeededSwap)
                          
                            'PRINT "Debug: " & "parted " & Trim(sDrive) & " -s \"mkpart primary reiserfs " & lFreeStart & "kb " & (lFreeEnd - lNeededSwap) & "kb\""
                          SHELL "parted " & Trim(sDrive) & " -s \"mkpart primary reiserfs " & lFreeStart & "kb " & (lFreeEnd - lNeededSwap) & "kb\"" WAIT 'iLastpart + 1 partition
                          EXEC ["mkfs.reiserfs", "-fq", sDrive & (iLastPartNo + 1)] WAIT 
                            PRINT " --- Created / partition preformatted to reiserfs " & Trim(sdrive) & (iLastPartNo + 1)
                       
                       SHELL "probepart | grep -i \"linux swap\"| cut -f 1 -d \' \'" TO sDump
                      sDump = Trim(sDump)   ' this is possibly an array
                        IF sDump THEN 
                          sDumparr = Split(sDump, "\n")
                          PRINT " ---+ Use existing swap partition -> " & sDumparr[0]
                          sSwapPart = Trim(sDumparr[0])
                        
                            
                        ELSE 
                       
                       
                          SHELL "parted " & Trim(sdrive) & " -s \"mkpart primary linux-swap " & (lFreeEnd - lNeededSwap) & "kb " & lFreeEnd & "kb\"" WAIT ' ilastpart + 2 partitiong
                            PRINT " --- Created swap partition " & Trim(sdrive) & (iLastPartNo + 2)
                          SHELL "mkswap " & Trim(sdrive) & (iLastPartNo + 2) WAIT 
                          SHELL "swapon " & Trim(sdrive) & (iLastPartNo + 2) WAIT 
                          sSwapPart = Trim(sdrive) & (iLastPartNo + 2)
                        END IF
                          sRootPart = Trim(sdrive) & (iLastPartNo + 1)
                          
                          
                 ELSE ' this method skips one number I think 
                      ' BEGIN BY CREATING AN EXTENDED PARTITION TO HOLD LOGICAL PARTITIONS IN IT
                      ' THIS WILL ADD 1 TO THE iLastPartition number 
                        SHELL "parted " & Trim(sdrive) & " -s \"mkpart extended " & lFreeStart & "kb " & lFreeEnd & "kb\"" WAIT 
                          ' I need to re-calculate the free space after this... the extended partition shaves a hair off the free space, so that can throw the whole thing off
                            SHELL "parted " & Trim(sDrive) & " unit kb print free | grep -i \"free space\" | tr -s \' \',\"\" | cut -f 2-4 -d \' \'" TO sPartedRes
                                          'Message(sPartedRes)
                                    sPartedRes = Trim(sPartedRes) ' | START | | END | | SIZE |
                                      sOutLine = Split(sPartedRes, Space(1))
                                        sFreeStart = sOutLine[0]
                                        sFreeEnd = sOutLine[1] 
                                        sFreeSize = sOutLine[2]
                                    ' I need to know where the free space stars and ends to do this.
                                    lFreeKB = ME.ConvertToKb(sFreeSize)
                                    lFreeStart = ME.ConvertToKb(sFreeStart)
                                    lFreeEnd = ME.ConvertToKb(sFreeEnd)
                            
                            ' PROCEED TO CREATE PARTITIONS IN NEWLY CALCULATED FREE SPACE
                          SHELL "parted " & Trim(sDrive) & " -s \"mkpart logical reiserfs " & lFreeStart & "kb " & (lFreeEnd - lNeededSwap) & "kb\"" WAIT 
                          'SHELL "echo yes | parted " & Trim(sdrive) & " mkfs reiserfs " & (iLastPartNo + 2) WAIT 
                          SHELL "mkfs.reiserfs -fq " & sDrive & (iLastPartNo + 2) WAIT 
                        
                        ' search for existing swap partitions
                      SHELL "probepart | grep -i \"linux swap\"| cut -f 1 -d \' \'" TO sDump
                      sDump = Trim(sDump)   ' this is possibly an array
                        IF sDump THEN 
                          sDumparr = Split(sDump, "\n")
                          PRINT " ---+ Use existing swap partition -> " & sDumparr[0]
                          sSwapPart = Trim(sDumparr[0])
                        
                            
                        ELSE 
                                                  
                          ' ####################### RECALCULATE FREE SPACE ########################################
                            SHELL "parted " & Trim(sDrive) & " unit gb print free | grep -i \"free space\" | tr -s \' \',\"\" | cut -f 2-4 -d \' \'" TO sPartedRes
                                          'Message(sPartedRes)
                                    sPartedRes = Trim(sPartedRes) ' | START | | END | | SIZE |
                                      sOutLine = Split(sPartedRes, Space(1))
                                        sFreeStart = sOutLine[0]
                                        sFreeEnd = sOutLine[1] 
                                        sFreeSize = sOutLine[2]
                            SHELL "parted " & Trim(sdrive) & " mkpart logical linux-swap " & sFreeStart & " " & sFreeEnd WAIT 
                            
                            
                                ' ^^^^^^^^ IN CASE THE ABOVE LINE DOESN'T WORK, THE FOLLOWING CODE MAY BE USED TO PERFORM THE SAME OPERATION ^^^^^^^^^^
                            
                            ' ' ' ' ' sDump = "#!/bin/bash \n" &
                            ' ' ' ' ' "parted " & Trim(sdrive) & " mkpart logical linux-swap " & sFreeStart & " " & sFreeEnd & " \n" &
                            ' ' ' ' ' "<<EOF \n" &
                            ' ' ' ' ' "yes \n" &
                            ' ' ' ' ' "EOF"
                            ' ' ' ' ' File.Save("/tmp/swapmaker", sDump)
                            ' ' ' ' ' SHELL "sh /tmp/swapmaker" WAIT 
                            sSwapPart = Trim(sdrive) & (iLastPartNo + 3)
                        END IF
                          sRootPart = Trim(sdrive) & (iLastPartNo + 2)
                          
                      END IF
                    
          END IF
    
    
    ME.tlSelAutoTarget.Text = ("Partitioning stage complete... Click") & Space(1) & ClsGlobal.fRunningMainForm.btnext.text & Space(1) & ("to continue")
     ME.MovieBox1.Playing = FALSE
     
     ' set the flag for partition reading
     ClsGlobal.bAutoPartition = TRUE
     
     sPart = Left(sRootPart, Len("/dev/hda"))
     sNum = Right(sRootPart, Len(sRootPart) - Len(sPart))
         
      ' get the size of the / partition that was just created.
      SHELL "parted " & sPart & " unit GB print | grep \"^ " & sNum & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump      
      
      sDump = Trim(sDump)      
      ClsGlobal.sTargetRoot = sRootPart & "-" & Trim(sDump)
     
     ' get the size of the swap partition that was just created.
        sPart = Left(sSwapPart, Len("/dev/hda"))
        sNum = Right(sSwapPart, Len(sSwapPart) - Len(sPart))
      SHELL "parted " & sPart & " unit GB print | grep \"^ " & sNum & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump        
        sDump = Trim(sDump)
     ClsGlobal.sTargetSwap = sSwapPart & "-" & Trim(sDump)
      
      
     
END




PUBLIC FUNCTION GETNEXT() AS String
  
  RETURN "Step7"
  
END
PUBLIC SUB STARTUP()
  

  DIM i AS Integer
  
      objTargetOptions = NEW Object[]
  ME.LIST_FREE_SPACE()
  
    FOR EACH RadioButton1 IN objTargetOptions
      IF RadioButton1.Enabled = TRUE THEN INC i
    NEXT 
  
  IF i < 1 THEN 
    Message.Error(("We are unable to find any hard disks with enough unpartitioned space for this operation.") & "<br>" &
    ("Please consider using another partitioning method."))
    
    ME.tlSelAutoTarget.Text = ("Unable to find any hard drives with enough unpartitioned space. Please go back and select  another partitioning method")
  END IF
  
  
END



PUBLIC SUB ONEXIT()
  
  ' CREATE THE PARTITIONS NOW
  ME.PERFORM_PARTITIONING()
  
END

PUBLIC SUB Form_Resize()

  ME.hpanel3.Height = ME.ClientH - ME.HPanel3.Top - 12
  ME.HPanel4.Height = ME.HPanel3.Height

END

PUBLIC SUB Form_Menu()

  'ME.PERFORM_PARTITIONING()

END
