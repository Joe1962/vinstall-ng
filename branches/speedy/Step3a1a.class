' Gambas class file
'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

PRIVATE sStatus AS String
PRIVATE hproc AS Process
PUBLIC SUB Form_Open()
  
  ME.tlbanner.Text = "<h2>" & ("Create Linux Partition Scheme in") & Space(1) & ClsGlobal.sFullDiscToWipe & "</h2>"
  ME.MovieBox1.Path = "images/throbber.gif"
  ME.MovieBox1.Playing = FALSE
  
    

END

PUBLIC SUB DESTROY_CURRENT_DATA()
  
  DIM sDrive AS String = Trim(ClsGlobal.sFullDiscToWipe)
  DIM sPartitions, sPart AS String
  DIM sPartList AS String[]
  DIM i AS Integer
    
    PRINT " --\\\\-- Selected target : " & sDrive
    'SHELL "parted " & sDrive & " print | grep \"^ [0-9]\" | tr -s \' \',\"\" | cut -f 1-2 -d \"\"" TO sPartitions
    SHELL "parted " & sDrive & " print | grep \"^ [0-9]\" | tr -s \' \',\"\" | cut -f 1-2 -d \' \'" TO sPartitions
    sPartitions = Trim(sPartitions)
      
      IF NOT sPartitions THEN 
        PRINT "  --\\__ Target device is empty (no partitions found) "
        RETURN 
      END IF
    sPartList = Split(sPartitions, "\n")
      FOR i = 0 TO sPartList.Max
        sPart = Trim(sPartList[i])
        ' remove this partition
            PRINT "   \\__- Deleting partition " & sPart 
                hproc = SHELL "parted " & sDrive & " rm " & sPart & " 1>/dev/null " WAIT 
                  IF hproc.Value > 0 THEN 
                    Message.Error(("There has been an error deleting") & Space(1) & sDrive & sPart & "." & "<br>" &
                    ("Please make sure the drive or partition is not being used by some other program"))
                    'BREAK 
                    PRINT "     \\- FAILED!"
                      sStatus = ("Error deleting existing partitions... Please try another partitioning method")
                    RETURN 
                  END IF
                    
            PRINT "     \\- Done"
      NEXT 
      
END


PUBLIC SUB CREATE_NEW_PARTITIONS()
  
  DIM lRunningSwap, lNeededSwap, lTotalRAM, lTotalFreekb AS Long
  DIM sDump, sSwapList, sSwapPart, sRootpart, sDrive AS String
  DIM sResults, sPartedDetails AS String[]
  DIM sPartedOutput AS String
  DIM sFreeStart, sFreeEnd, sFreeTotal AS String
  
    
    sDrive = Trim(ClsGlobal.sFullDiscToWipe)
    ' First determine how much swap we need
      SHELL "free | grep \"^Swap\" | tr -s \' \',\"\" | cut -f 2 -d \' \'" TO sDump
        sDump = Trim(sDump)
          IF sDump THEN   
            ' swap exists
              SELECT CASE Message.Question(("Vectorlinux has detected an existing swap partition in your system.") & "<br>" &
                ("Would you like to let VectorLinux use this partition or create a new one?"), ("Use Existing"), ("Create New"))
                CASE 1
                  ' use existing partition
                  SHELL "probepart | grep \"^/dev\" | grep -i \"linux swap\" | tr -s \' \',\"\" | cut -f 1 -d \' \'" TO sSwapList
                    sSwapList = Trim(sSwapList)
                      sResults = Split(sSwapList, "\n")
                      sSwapPart = sResults[0]
                PRINT " --- Use existing swap partition " & sSwapPart
                
                ' detect size of swap partition
                SHELL "parted " & Left(sSwapPart, Len("/dev/hda")) & " unit GB print | grep \"^ " & Right(sSwapPart, Len(sSwapPart) - Len("/dev/hda")) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
                'Message("Size dump for swap " & sDump)
                'SHELL "echo \"" & Trim(sDump) & "\" cut -f 3 -d \' \'" TO sDump
                
            ClsGlobal.sTargetSwap = Trim(sSwapPart & "-" & Trim(sDump)) ' set the address to the swap partition.
                      'Message("Using swap " & sSwapPart)
              END SELECT 
          ELSE ' no swap found
          ' we take care of this outside this if  
          END IF
          
  
      
      IF NOT sSwapPart THEN 
        'detect ram
        PRINT "  - Calculating system ram"
        SHELL "free | grep \"^Mem\" |tr -s \' \',\"\" | cut -f 2 -d \' \'" TO sDump
        sDump = Trim(sDump)
          lTotalRAM = sDump
        PRINT "  -\\- " & lTotalRAM & " KB found"
        PRINT "  - Determining amount of swap space needed "
            IF lTotalRAM <= 524288 THEN 
              lNeededSwap = lTotalRAM * 2
            ELSE 
              lNeededSwap = lTotalRAM
            END IF
        PRINT "  -\\- " & lNeededSwap & " KB needed for swap"
        
        ' now create partitions for swap and /
        SHELL "parted " & sDrive & " unit kb print free | grep -i \"free space\"" TO sPartedOutput
          sPartedOutput = Trim(sPartedOutput)
          'Number  Start   End         Size        Type  File system  Flags
          sPartedDetails = Split(sPartedOutput, Space(1))
            lTotalFreekb = Left(sPartedDetails[2], Len(sPartedDetails[2]) - 2)
            'Message.Info("Total free space size on " & sDrive & " = " & lTotalFreekb)
           ' create primary partition for /
            PRINT " --- Creating / partition at " & sDrive & "1 ... Size = " & (lTotalFreekb - lNeededSwap) & " Kb as reiserfs"
        SHELL "parted " & sDrive & " unit kb mkpart primary reiserfs " & sPartedDetails[0] & Space(1) & (lTotalFreekb - lNeededSwap) & "kb 1 > /dev/null" WAIT 
    
          ' get the free space again to create the right size swap partition with the remainder of the free space
        SHELL "parted " & sDrive & " unit kb print free | grep -i \"free space\"" TO sPartedOutput
          sPartedOutput = Trim(sPartedOutput)
          'Message(sPartedOutput)
          'Number  Start   End         Size        Type  File system  Flags
          sPartedDetails = Split(sPartedOutput, Space(1))
          'Message("Start " & Trim(sPartedDetails[0]) & " End " & Trim(sPartedDetails[2]))
          PRINT " --- Creating swap partition at " & sDrive & "2 ... Size = " & lNeededSwap & " Kb"
        SHELL "parted " & sDrive & " mkpartfs primary linux-swap " & Trim(sPartedDetails[0]) & " " & Trim(sPartedDetails[2]) & " 1 > /dev/null " WAIT 
        
        ' get partition sizes now
          SHELL "parted " & sDrive & " unit GB print | grep \"^ 1\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
          'SHELL "parted " & Left(sSwapPart, Len("/dev/hda")) & " unit GB print | grep \"^ " & Right(sSwapPart, Len(sSwapPart) - Len("/dev/hda")) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
'          SHELL "echo \"" & Trim(sDump) & " cut -f 3 -d \' \'" TO sDump
             ClsGlobal.sTargetRoot = Trim(sDrive & "1" & "-" & Trim(sDump))
          SHELL "parted " & sDrive & " unit GB print | grep \"^ 2\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
          'SHELL "echo \"" & Trim(sDump) & " cut -f 3 -d \' \'" TO sDump
            ClsGlobal.sTargetSwap = Trim(sDrive & "2" & "-" & Trim(sDump))
          
        
      ELSE 
        ' only create a / partition... we'll be using a shared swap area
          SHELL "parted " & sDrive & " unit gb print free | grep -i \"free space\"" TO sPartedOutput
          sPartedOutput = Trim(sPartedOutput)
          'Number  Start   End         Size        Type  File system  Flags
            sPartedDetails = Split(sPartedOutput, Space(1))
          PRINT " --- Create / partition " & sDrive & "1 Size = " & Trim(sPartedDetails[4]) & " preformatted to reiserfs"
          SHELL "parted " & sDrive & " mkpart primary reiserfs " & Trim(sPartedDetails[0]) & Space(1) & Trim(sPartedDetails[2]) WAIT 
            IF MdlMain.FORMAT_THIS_PARTITION(sDrive & "1", "reiserfs") > 0 THEN 
              sStatus = ("Failed to format partitions, please try another partitioning method")
              RETURN 
            END IF
          
          SHELL "parted " & sDrive & " unit GB print | grep \"^ 1\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
          'SHELL "echo \"" & Trim(sDump) & " cut -f 3 -d \' \'" TO sDump
            ClsGlobal.sTargetRoot = Trim(sDrive & "1" & "-" & Trim(sDump))
            
          '
          'ClsGlobal.sTargetRoot = sDrive & "1"
          'SHELL "mkfs.reiserfs -q " & sDrive & "1" WAIT 
          'Message(sPartedDetails[0])
          'Message(sPartedDetails[1])
          'Message(sPartedDetails[2])

      END IF
      
      sStatus = ("Partitioning stage complete. Click") & Space(1) & "\"" & ClsGlobal.fRunningMainForm.btnext.text & "\"" & Space(1) & ("to continue")
  
END



PUBLIC SUB StartUp()

    SELECT CASE Message.Warning("<b>" & ("WARNING:") & "</b>" & Space(1) & ("All existing data in") & Space(1) & ClsGlobal.sFullDiscToWipe & Space(1) & ("is about to be deleted.") & "<br>" &
    ("This step cannot be undone. Are you sure you want to continue?"), ("Yes"), ("No"))
      CASE 1
        'Message("Yes")
        
        ME.tlWarning.Text = ("Preparing hard disk for new partitioning structure. Please wait")
        ME.MovieBox1.Playing = TRUE
          WITH ClsGlobal.fRunningMainForm
            .btnext.enabled = FALSE
            .btback.enabled = FALSE
            .btquit.enabled = FALSE
          END WITH 
        ME.DESTROY_CURRENT_DATA()
        ME.CREATE_NEW_PARTITIONS()
        ME.tlWarning.Text = sStatus '("Hard drive partitioned successfully. Click") & Space(1) & ClsGlobal.fRunningMainForm.btnext.text & Space(1) & ("to continue.")
        ME.MovieBox1.Playing = FALSE
        ME.MovieBox1.Enabled = FALSE
        WITH ClsGlobal.fRunningMainForm
            .btnext.enabled = TRUE
            .btback.enabled = TRUE
            .btquit.enabled = TRUE
        END WITH 
        
      CASE 2 
        'Message("No")
        ME.tlWarning.Text = ("Operation cancelled by user. No changes have been made to the system")
    END SELECT 

END 

PUBLIC SUB OnExit()
  
  
  
END



PUBLIC FUNCTION GetNext() AS String
  
  RETURN "Step7"
  
END
