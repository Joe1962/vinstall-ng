' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 
PUBLIC SUB GO_WITH_SELECTED(sDev AS String, sISONAME AS String) ' this will mount the drive and display the license agreement
  
  DIM sPathToLic AS String = ClsGlobal.sSourceMnt &/ "COPYING"
  DIM sAddy AS String = Right(sDev, Len(sDev) - RInStr(sDev, "/"))
   
  
  IF sISONAME OR sISONAME <> "" THEN 
    'SHELL "sudo mount " & sDev & " /mnt/loop" WAIT ' will switch places here .. the device will mount to loop and the iso will mount to the mount point
    SHELL "mkdir -p /mnt" &/ sAddy & " && mount " & sDev & Space(1) & "/mnt" &/ sAddy WAIT 
    SHELL "mount -o loop /mnt" &/ sAddy &/ sISONAME & Space(1) & ClsGlobal.sSourceMnt WAIT 
      
    'SHELL "sudo umount /mnt/loop" WAIT 
  ELSE 
         
    SHELL "mount " & sDev & Space(1) & ClsGlobal.sSourceMnt & " 2>/root/err" & " >/root/log" WAIT 
  END IF
  
  ' display the license agreement text
'  FrmLicense.taLicense.Text = SConv(File.Load(sPathToLic))
  
  ' This will also set the default variables for distro name and version to clsglobal
    MdlCore.SET_DECISSION(ClsGlobal.sSourceMnt)
      ' save the credits file to temp
      File.Save(Temp$("Credits"), DConv(File.Load(ClsGlobal.sSourceMnt &/ "CREDIT")))
  

END
 
 
 PUBLIC FUNCTION CHECK_IF_REBOOT_NEEDED() AS Boolean
 
 ' KNOWN BUG:
 ' This will make the user restart if there are FAT* partitions anywhere on the box
 ' even if that drive was not modified
 ' END OF BUG -- FIX SOON
 
 DIM sFATList AS String
 DIM sFAT32List AS String
 
 SHELL "probepart | grep -e \"^/dev.*FAT32$\" | sed \'s/\\*/ /\' | grep -e \"/dev\"" TO sFAT32List
 SHELL "probepart | grep -e \"^/dev.*FAT$\" | sed \'s/\\*/ /\'|grep -e \" /dev\"" TO sFATList
 
 sFAT32List = Trim(sFAT32List)
 sFATList = Trim(sFATList)
 
 IF sFAT32List <> "" THEN 
  RETURN TRUE ' reboot needed
 ELSE IF sFATList <> "" THEN 
  RETURN TRUE ' reboot needed
 ELSE 
  RETURN FALSE ' no reboot needed
 END IF
 
    
END

PUBLIC FUNCTION FORMAT_SELECTED_PARTITIONS() AS Integer
  
  'DIM hproc AS Process
  DIM sDump AS String


              
    
    SHELL "mkfs." & LCase(ClsPartSel.fRoot) & " || echo \'ERROR\'" TO sDump
      
            GOTO CHECK_OUTPUT
 
 
 IF ClsPartSel.sHome AND ClsPartSel.fhome <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fhome) & " || echo \'ERROR\'" TO sDump
    
    GOTO CHECK_OUTPUT
  END IF
  
 
 
 IF ClsPartSel.sOpt AND ClsPartSel.fOpt <> "Do not format" THEN 
 sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fOpt) & " || echo \'ERROR\'" TO sDump
     
        GOTO CHECK_OUTPUT
 END IF
 
 IF ClsPartSel.sUsr AND ClsPartSel.fUsr <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fUsr) & " || echo \'ERROR\'" TO sDump
    
      GOTO CHECK_OUTPUT
 END IF
 
 IF ClsPartSel.sVar AND ClsPartSel.fVar <> "Do not format" THEN 
  sDump = ""
  SHELL "mkfs." & LCase(ClsPartSel.fVar) & " || echo \'ERROR\'" TO sDump
    
    GOTO CHECK_OUTPUT
  END IF
  
  IF ClsPartSel.sTmp AND ClsPartSel.fTmp <> "Do not format" THEN 
    sDump = ""
       SHELL "mkfs." & LCase(ClsPartSel.fTmp) & " || echo \'FAILED\'" TO sDump
        
          GOTO CHECK_OUTPUT
  END IF
  
  
  
CHECK_OUTPUT:
 IF InStr(sDump, "ERROR") = TRUE THEN 
                RETURN 1 ' not good... stop right there
              ELSE 
                RETURN 0
              END IF  
  
END



PUBLIC SUB SHOW_PROGRESS_CONTROLS()
  
  WITH FrmInstallSys
  .tlCurrStepLbl.Visible = TRUE
    .pbInstallProg.Visible = TRUE
    .tlCurrPkg2.Visible = TRUE
    .pbInstallProg2.Visible = TRUE
  END WITH 
  
END

PUBLIC FUNCTION UPDATE_OVERALL_PROGRESS(iTotalPkgs AS Integer, iCurrPkg AS Integer) AS Float
  DIM fRet AS Float
   IF iTotalPkgs = 0 THEN 
     iTotalPkgs = 30
   ENDIF 

  fRet = iCurrPkg / iTotalPkgs
  fRet = Round(fRet, -2)
  RETURN fRet
  
END



PUBLIC FUNCTION CALCULATE_PACKAGE_COUNT(bCustom AS Boolean) AS Integer
  
  DIM sDump AS String
  DIM sTotalList AS String
  DIM i AS Integer
  DIM sList AS String[]
  DIM iQTY AS Integer
  
  ' let's get a package count
  IF bCustom = FALSE THEN ' DOING A FULL INSTALL
      ' SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF | grep ^BULK" TO sDump
      ' sDump = Trim(sDump)
      ' sTotalList = sTotalList & sDump
      ' sTotalList = Trim(sTotalList)
      ' sDump = ""
      ' SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF | grep ^CONF" TO sDump
      '   sTotalList = sTotalList & gb.NewLine & Trim(sDump)
      '   sDump = ""
      ' SHELL "cat " & ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT | grep ^\"PACKAGE NAME\"" TO sDump
      '   sTotalList = sTotalList & gb.NewLine & Trim(sDump)
      '   sDump = ""
      '   SHELL "ls /mnt/cdrom/packages/required/*.t?z" TO sDump
      '   sTotalList = sTotalList & gb.NewLine & Trim(sDump)
      '   sDump = ""
      '   ' split the array
      '     sList = Split(sTotalList, "\n")
      '       FOR i = 0 TO sList.Count - 1
      '         IF sList[i] = "" THEN 
      '           sList.Delete(i)
      '         END IF
      '       NEXT 
      '       iQTY = sList.Count
        SHELL "find " & ClsGlobal.sSourceMnt & " -name \"*.tlz\"|wc -l" TO iQTY
  ELSE ' GOING FOR CUSTOM INSTALL
        
  END IF
            
        
       RETURN iQTY   
      
  
  
END





PUBLIC SUB RUN_CREDITS()
  
  DIM sCreditFile AS String = DConv(File.Load(Temp("Credits")))  
  DIM tlOutput AS TextLabel = FrmInstallSys.tlCredits
  DIM sFile AS String[] = Split(sCreditFile, "\n")
  DIM i AS Integer
  tlOutput.Text = ""
    
    ' File.Save(Temp("Credits"), DConv(File.Load("/CREDIT")))
    ' sCreditFile = File.Load(Temp("Credits"))
    ' sFile = Split(sCreditFile, "\n")
  
  FOR i = 0 TO sFile.count - 1
      IF Left(Trim(sFile[i]), Len("M0E-lnx")) = "M0E-lnx" THEN 
              sFile[i] = "M0E-lnx  [ vpackager, vasmCC, GUI installer ]"
      ELSE IF Left(Trim(sFile[i]), Len("Uelsk8s")) = "Uelsk8s" THEN 
          sFile[i] = "Uelks8s [ vlthemeswitch, ISO Master, Gui Installer ]"
      ELSE 
        sFile[i] = sFile[i]
      END IF
      'tlOutput.text = tlOutput.text & "<br>" & sFile[i]
      'tlOutput.Adjust
    tlOutput.Text = tlOutput.Text & " ~ " & sFile[i]
'    tlOutput.Text = sFile[i]
    
  NEXT 
  tlOutput.Width = MdlObjSizer.get_object_width(tlOutput.Text) + 24
  WAIT 
  FrmInstallSys.tmCredits.Enabled = TRUE
    
END

PUBLIC SUB BEGIN_INSTALLATION()
    
  
  MdlCore.LOCK_GUI()
    FrmInstallSys.tlCurrPkg.text = ("Activating swap space")
  MdlInstallSys.ACTIVATE_SWAP_SPACE()
    FrmInstallSys.tlCurrPkg.text = ("Preparing filesystems")
  MdlPartFrmt.PREPARE_ALL_PARTITIONS() ' This will start the install process
  
  
END

