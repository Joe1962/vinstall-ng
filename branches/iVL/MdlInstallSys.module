' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 PRIVATE hproc AS Process
 PRIVATE sDump AS String
 PRIVATE sErr AS String

 

PUBLIC FUNCTION MOUNT_DEFINED_PARTITIONS() AS Integer

 DIM cb AS ComboBox
  ' this is where we need to set the mount target
  ClsGlobal.sTargetMnt = "/mnt/target"
  MdlCore.WARN_STATUS("")
  
    IF Exist(ClsGlobal.sTargetMnt) = FALSE THEN 
      TRY MKDIR ClsGlobal.sTargetMnt
    END IF   
    'SHELL "umount " & ClsGlobal.sTargetMnt WAIT 'clear the mount point
    EXEC ["umount", ClsGlobal.sTargetMnt] WAIT 
    
    
    '/DISABLED FOR TESTING INSTALL ONLY
    SHELL "mount " & ClsPartSel.sRoot & Space(1) & ClsGlobal.sTargetMnt WAIT  'moun the root partition first
    IF ClsPartSel.sHome THEN 
       SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "home" WAIT 
       SHELL "mount " & ClsPartSel.sHome & Space(1) & ClsGlobal.sTargetMnt &/ "home -t " & LCase(ClsPartSel.fhome) WAIT 'mount the home partition if defined
      
    END IF
    IF ClsPartSel.sUsr THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "usr" WAIT 
      SHELL "mount " & ClsPartSel.sUsr & Space(1) & ClsGlobal.sTargetMnt &/ "usr -t" & ClsPartSel.fUsr WAIT ' mount the user partition
    END IF
    IF ClsPartSel.sOpt THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "opt" WAIT 
      SHELL "mount " & ClsPartSel.sOpt & Space(1) & ClsGlobal.sTargetMnt &/ "opt -t " & ClsPartSel.fOpt WAIT 'mount the opt partitiong
    END IF
    IF ClsPartSel.sVar THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "var" WAIT 
      SHELL "mount " & ClsPartSel.sVar & Space(1) & ClsGlobal.sTargetMnt &/ "var -t " & ClsPartSel.fVar WAIT 
    END IF
    IF ClsPartSel.sTmp THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "tmp" WAIT 
      SHELL "mount " & ClsPartSel.sTmp & Space(1) & ClsGlobal.sTargetMnt &/ "tmp -t " & ClsPartSel.fTmp WAIT 
    END IF

    
      IF ClsPkgSel.bCustom = TRUE THEN 
        MdlInstallCustom.PERFORM_CUSTOM_INSTALL()
      ELSE 
        MdlInstallSys.PERFORM_FULL_INSTALL()
      END IF  
      
      FOR EACH cb IN MdlPartSel.oMountPoints
        IF Left(cb.Text, Len("/mnt")) = "/mnt" THEN EXEC ["mkdir", "-p", ClsGlobal.sTargetMnt &/ cb.Text] WAIT 
      NEXT 
      MdlCore.warn_status_off
END

PUBLIC SUB WRITE_NEW_DISTRO_ID()
  
  DIM sBuildDate AS String
  DIM sContent AS String
  
  SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF | grep ^builddate | cut -f 2 -d \'=\'" TO sBuildDate
    sBuildDate = Trim(sBuildDate)
      sBuildDate = Replace(sBuildDate, "\"", "")
      sBuildDate = Replace(sBuildDate, "\'", "")
      
    sContent = ClsGlobal.DISTRO & Space(1) & ClsGlobal.VERSION & Space(1) & "Built on" & Space(1) & sBuildDate
        File.Save(ClsGlobal.sTargetMnt &/ "etc" &/ "vector-version", SConv(sContent))
    'Message.Info(sContent)
  
END




PUBLIC FUNCTION WRITE_NEW_FSTAB() AS Integer
  
  DIM sEntry AS String
  DIM sPartition AS String
  DIM sMountPoint AS String
  DIM sMntOpts AS String
  DIM i, ii AS Integer
  DIM sLinPart AS String
  DIM sLinMntPnt AS String
  DIM sWinPart AS String
  DIM sWinMntPnt AS String
  DIM sFstab AS String
  DIM sPartFmt AS String
  DIM cb, mt AS ComboBox
  DIM sRes, sDrive, sBlank, sPartNo AS String

 
  ' make the changes show up on the steps now  
  FrmInstallSys.tlCurrPkg.Text = ("Writing new /etc/fstab to system")
  
  sFstab = "# /etc/fstab: static file system information.\n" &
  "#\n" &
"#The following is an example.Please see fstab(5) for further details.\n" &
"#Please refer to mount(1) for a complete description OF mount options.\n" &
"#\n" &
"#Format:\n" &
"# < file system > < mount point > < type > < options > < dump > < pass >\n" &
"#\n" &
"#dump(8)uses the < dump > field to determine which file systems need \n" &
"# to be dumped.fsck(8)uses the < pass > column TO determine which file \n" &
"#systems need TO be checked - - the root file system should have a 1 in \n" &
"#this field, other file systems a 2, AND any file systems that should \n" &
"#not be checked(such AS MS - initrd / mnt OR NFS file systems)a 0.\n\n\n" &
"#The Linux partitions\n"



sFstab = sFstab & gb.NewLine


' nOW LETS' GET THE REST OF THE PARTITIONS IN THERE
FOR EACH CB IN MdlPartSel.oMountPoints
    IF cb.text <> ("Not Used") THEN 
      
    
  'IF Left(Trim(cb.text), Len("/mnt")) = "/mnt" THEN 
    sDrive = Left(cb.tag, Len("/dev/hda"))
    sPartNo = Right(cb.tag, Len(cb.tag) - Len(sDrive))
    
        IF Len(sPartNo) > 1 THEN 
          sBlank = ""
        ELSE 
          sBlank = " "
        END IF
             IF cb.tag = ClsPartSel.sRoot THEN 
                FOR EACH mt IN MdlPartSel.oFsTypes
                  IF mt.tag = cb.tag THEN 
                    sFstab = sFstab & "\n" & 
                    mt.tag & Space(5) & Space(5) & "/" & Space(5) & Trim(mt.text) & Space(5) & "defaults 0 1" & "\n"

                  END IF
                NEXT 
             ELSE 
            FOR EACH mt IN MdlPartSel.oFsTypes
              IF mt.Tag = cb.Tag THEN 
                
                
                IF mt.text = ("Do not format") THEN                   
                  SHELL "export sfmt=$(parted " & sDrive & " print | grep ^\'" & sBlank & sPartNo & "\'); echo $sfmt | cut -f 6 -d \' \'" TO sRes
                ELSE 
                  sRes = LCase(mt.text)
                END IF
              END IF
            NEXT                 
        
        sFstab = sFstab & cb.tag & Space(5) & Trim(cb.Text) & Space(5) & Trim(sRes) & Space(5) & ME.fS_oPTIONS(sRes) & Space(5) & " 0 2 " & "\n"
    END IF
    TRY MKDIR ClsGlobal.sTargetMnt &/ cb.Text
  END IF
NEXT 

sFstab = sFstab & "\n\n" &
"# Shared Windows/Linux partition" &
"#/dev/hda1   /mnt/dos  msdos  umask=0   0  0 \n" &
"#/dev/hda1   /mnt/win  vfat   fmask=111,dmask=0,quiet,shortname=mixed,user  0  0 \n" &
"#/dev/hda1   /mnt/win  ntfs   umask=0   0  0\n" 

' LET'S GET THE WINDOWS PARTITIONS IN HERE
  IF MdlWinDrives.oWMntPoints THEN 
FOR EACH cb IN MdlWinDrives.oWMntPoints
  IF cb.text <> ("Do not mount") THEN 
    sDrive = Left(cb.tag, Len("/dev/hda"))
    spartNo = Right(cb.tag, Len(cb.tag) - Len(sDrive))
      IF Len(sPartNo) > 1 THEN 
        sBlank = "" 
      ELSE 
        sBlank = " " 
      END IF
      SHELL "export sfmt=$(parted " & sDrive & " print | grep ^\'" & sBlank & sPartNo & "\'); echo $sfmt | cut -f 6 -d \' \'" TO sRes
      sRes = Trim(sRes)
        IF sRes = "fat32" THEN 
          sRes = "vfat"
        ELSE IF sRes = "fat16" THEN 
          sRes = "vfat"
        ELSE IF sRes LIKE "ntfs" THEN 
          sRes = "ntfs-3g"
        END IF
      sFstab = sFstab & "\n" & 
      cb.tag & Space(5) & Trim(cb.text) & Space(5) & Trim(sRes) & Space(5) & ME.fS_oPTIONS(sRes) & " 0  0 "
  END IF
      ' create the mount point for the target
      TRY MKDIR ClsGlobal.sTargetMnt &/ cb.Text
NEXT 
  END IF

sFstab = sFstab & "\n\n" &
"# Floppy disks \n" &
"# The 'noauto' option indicates that the file system should not be mounted \n" &
"# with 'mount -a' 'user' indicates that normal users are allowed to mount \n" &
"# the file system. \n" &
"/dev/fd0   /mnt/floppy  auto  defaults,noauto,user  0 0 \n" &
"#/dev/fd1  /mnt/floppy  auto  defaults,noauto,user  0 0 \n\n" &
"# If you have a ls-120 floppy drive, it could be on /dev/hda b c d etc.\n" &
"#/dev/hdd  /mnt/ls120  auto  defaults,noauto,user  0 0 \n\n" &
"# CDROM, CDWRITER, DVD \n" &
"/dev/cdrom    /media/cdrom  iso9660  defaults,noauto,ro,user  0 0 \n" &
"#/dev/cdwriter /media/cdwriter  iso9660  defaults,noauto,rw,user  0 0 \n" &
"#/dev/dvd      /media/dvd   auto  defaults,noauto,ro,user  0 0\n\n" &
"# NFS file systems:\n" &
"#linux01.gwdg.de:/suse/6.3/i386.de  /mnt/nfs  nfs  defaults  0 0\n\n" &
"# proc file system:\n" &
"proc  /proc  proc  defaults  0 0\n\n" &
"# Unix98 devpts filesystem: \n" &
"none  /dev/pts  devpts  gid=5,mode=666  0 0\n\n" &
"# Shared memory filesystem: \n" &
"tmpfs   /dev/shm    tmpfs defaults 0  0 \n\n" &
"# Basic USB filesystem\n" &
"sysfs  /sys  sysfs  defaults  0 0\n" &
"usbfs /proc/bus/usb usbfs rw,devmode=0666 0 0\n\n" &
"# example of a VFAT USB pendrive\n" &
"#/dev/sda1  /mnt/pendrive vfat   fmask=111,dmask=0,noauto,user,quiet,shortname=mixed 0 0\n\n" &
"# Swap partitions\n" &
"# The 'sw' option means auto activating with 'swapon -a'.\n"
  ' This will add all the swap partitions to fstab
  FOR EACH cb IN MdlPartSel.oSwaps
    IF cb.text <> ("Not Used") THEN 
    sFstab = sFstab & "\n" &
    cb.Tag & Space(1) & "none" & Space(1) & "swap" & Space(1) & "sw" & Space(1) & "0" & Space(1) & "0" & gb.NewLine
    END IF
  NEXT 
  
 

sFstab = sFstab & "\n"
' Wheewww!... that's the whole fstab there... Please fix the win partitions
 

  ' now save the file to /etc/fstab
      IF Exist(ClsGlobal.sTargetMnt &/ "etc") = FALSE THEN 
        MKDIR ClsGlobal.sTargetMnt &/ "etc"
      END IF
    File.Save(ClsGlobal.sTargetMnt &/ "etc" &/ "fstab", SConv(sFstab))
' ' ' ' ' ' ' ' ' ' ' ' '     File.Save("/home/vluser/Area-51/fstab", SConv(sFstab)) ' test line
 
END 


PUBLIC FUNCTION fS_oPTIONS(sType AS String) AS String
  
    DIM sMntOpts AS String
    
    SELECT CASE LCase(sType)
      CASE "reiserfs"
        sMntOpts = "noatime"
      CASE "vfat", "fat32", "fat16"
        sMntOpts = "fmask=111,dmask=0,gid=users,shortname=mixed,quiet,user"
      CASE "ntfs"
        sMntOpts = "umask=0,gid=users,user"
      CASE "ntfs-3g"
        sMntOpts = "defaults,allow_other,umask=0,users,nls=utf8,noexec"
      CASE "ext2", "ext3"
        sMntOpts = "defaults"
      CASE ELSE 
        sMntOpts = "defaults"
    END SELECT 
    
    RETURN sMntOpts  
END

PUBLIC SUB ACTIVATE_SWAP_SPACE()
  
  DIM cb AS ComboBox
  DIM sDump AS String
  
  FOR EACH cb IN MdlPartSel.oSwaps
  IF cb.Text = "Swap" THEN 
    SHELL "cat /etc/fstab | grep ^" & cb.Tag TO sDump
        sDump = Trim(sDump)
          IF Len(sDump) < 1 THEN 
              SHELL "echo \'" & cb.Tag & " none swap sw 0 0 \' >> /etc/fstab" WAIT 
          END IF
'  NEXT 
  'SHELL "swapon -a" WAIT 
  
  END IF
  NEXT 
  EXEC ["swapon", "-a"] WAIT 
END




PUBLIC SUB PERFORM_FULL_INSTALL()
        
  DIM iret AS Integer  
  ClsGlobal.sTargetMnt = "/mnt/target"
  MdlSetup.SHOW_PROGRESS_CONTROLS()
  WITH FMain
      .tvPlan["Inst1"].Selected = TRUE
      .tvPlan["Inst1"].Picture = MdlCore.sNowPic
      .tvPlan["Inst0"].Picture = MdlCore.sDonePic
    END WITH   
  
    ClsGlobal.iPkgTot = MdlSetup.CALCULATE_PACKAGE_COUNT(FALSE)
    'Message.Info("Total packages = " & iPkgCnt)
    PRINT "Total packages to be installed " & ClsGlobal.iPkgTot

    PRINT "Installing bulks"
    MdlSetup.SHOW_PROGRESS_CONTROLS()
    iret = ME.INSTALL_BULK_PACKAGES()
  IF iret <> 0 THEN 
    PRINT "Error installing bulks ... exit"
    RETURN 
  END IF

  PRINT "installing packages"
  iret = ME.INSTALL_PACKAGES_NEW()
    IF iret <> 0 THEN 
      PRINT "error installing packages ... exit"
      RETURN 
    END IF

    PRINT "Installing packages/required"
    'MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = ME.INSTALL_REQUIRED_PACKAGES()
    IF iret <> 0 THEN 
      PRINT "Error installing packages/required ... exit"
      RETURN 
    END IF

    PRINT "installing CONFIG packages from SETUP.CONF"
    'MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = ME.INSTALL_CONFIG_PACKAGES()
      IF iret <> 0 THEN 
        PRINT "Error installing config packages ... exit"
        RETURN 
      END IF
      PRINT "installing kernels"
      'MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = MdlInstallCustom.INSTALL_KERNELS()
    IF iret <> 0 THEN 
      PRINT "Error installing kernels ... exit "
      RETURN 
    END IF
    
  PRINT "Binding and config"
  MdlConfLilo.PERFORM_BINDING()
  'iret = MdlConfLilo.PERFORM_BINDING()
  'IF iret <> 0 THEN 
  '  Message.Error(("Unable to Bind Mount. ") & gb.NewLine & sErr)
  '  RETURN 
  'END IF
  
    ' WRITE THE FSTAB NOW
  MdlInstallSys.WRITE_NEW_FSTAB()
  FrmInstallSys.pbInstallProg.Value = 1
  FrmInstallSys.pbInstallProg2.Value = 1
  'Message.Info("Vectorlinux is now installed in your system. Please click next to configure it.")
  FrmInstallSys.tlBanner.Text = "<h3>" & ("Vectorlinux is now installed in your system. Please click") & Space(1) & FMain.btnext.text & Space(1) & ("to configure it.") & "</h3>"
  FrmInstallSys.tlCurrPkg.Text = "<h3>" & ("Packages have been installed in your system. Please click") & Space(1) & FMain.btnext.text & Space(1) & ("to configure it.") & "</h3>"
  Message.Info(ClsGlobal.DISTRO & Space(1) & ("installation is complete. Click next to begin system configuration"))
  FrmCredits.TextLabel1.Text = ""
  FrmCredits.Timer1.Stop
  FrmCredits.ScrollView1.Scroll(0, 200)
  WITH FMain
    .btQuit.Enabled = TRUE
    .btQuit.ForeColor = Color.Black
    .btnext.Enabled = TRUE
    .btnext.ForeColor = Color.Black
  END WITH 
  'MdlCore.unlock_gui()      
END


PUBLIC FUNCTION INSTALL_PACKAGES_NEW() AS Integer
  
  DIM sFile AS String = File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT")
  DIM arrFile AS String[]
  DIM i AS Integer
  DIM sLine AS String
  DIM vPgsSize AS Variant
  DIM sPkgPath AS String
  DIM sPkgName AS String
  DIM vTargetSize AS Variant  
      
      
      'Message("Installing packages")
      arrFile = Split(sFile, "\n")
        FOR i = 0 TO arrFile.Count - 1
          FrmInstallSys.pbInstallProg.Value = 0
          sLine = Trim(arrFile[i])
            IF Left(sLine, Len("PACKAGE_NAME")) = "PACKAGE NAME" THEN 
              sPkgName = Trim(Right(sLine, Len(sLine) - InStr(sLine, ":")))
              sPkgPath = Right(Right(arrFile[i + 1], Len(arrFile[i + 1]) - InStr(arrFile[i + 1], ":")), -4)
              vPgsSize = Left(Right(arrFile[i + 3], Len(arrFile[i + 3]) - InStr(arrFile[i + 3], ":")), -2)
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sPkgName & " ..."
                ' now install the package
                 SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO vTargetSize
                    PRINT "installing " & ClsGlobal.sSourceMnt &/ "packages" &/ sPkgPath &/ sPkgName
                    INC ClsGlobal.iPkgNum
                    'ME.PACKAGE_INSTALL(ClsGlobal.sSourceMnt &/ "packages" &/ sPkgPath &/ sPkgName)
                        ' move the process here locally
                        SHELL "echo \"\" /tmp/installdump" WAIT 
                          'hproc = SHELL "installpkg " & ClsGlobal.sSourceMnt &/ "packages" &/ sPkgPath &/ sPkgName & " -R " & ClsGlobal.sTargetMnt & " 2> /tmp/installdump"
                          hproc = EXEC ["installpkg", ClsGlobal.sSourceMnt &/ "packages" &/ sPkgPath &/ sPkgName, "-R", ClsGlobal.sTargetMnt]
                      WAIT 
                        IF hproc.State = Process.Running THEN 
                          REPEAT 
                            WAIT 1
                              ' update progress here
                              ME.UPDATE_STEP_PROGRESS(CFloat(vTargetSize), CFloat(vPgsSize), ClsGlobal.iPkgNum)
                          UNTIL 
                            hproc.State = Process.Stopped
                        END IF
                        'IF InStr(sDump, "FAILED") > 0 THEN 
                          IF hproc.value > 0 THEN 
                  PRINT sPkgName & " failed to install " 
                  RETURN 1
                ELSE 
                  'RETURN 0
                END IF
            END IF
        FrmInstallSys.pbInstallProg.Value = 1
        WAIT 
        FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(ClsGlobal.iPkgCnt, ClsGlobal.iPkgNum)
        NEXT 
        INC ClsGlobal.iPkgNum
        'error check
                IF InStr(sDump, "FAILED") > 0 THEN 
                  PRINT sPkgName & " failed to install " 
                  RETURN 1
                ELSE 
                  'RETURN 0
                END IF
      'Message("End Installing Packages")
END


PUBLIC FUNCTION INSTALL_BULK_PACKAGES() AS Integer
  DIM sRawList AS String
  DIM sList AS String[]
  DIM sCount AS String[]
  DIM sTrimmed AS String
  DIM sLineArr AS String[]
  DIM sBulkPath AS String
  DIM vBulkSize AS Variant
  DIM sBulkDesc AS String
  DIM vTargetSize AS Variant
  DIM i AS Integer
  'DIM sFile AS String = File.Load(ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF")
  DIM sLine AS String
  
     SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF | grep ^BULK" TO sRawList
     '   sList = Split(File.Load(Temp$("SETUP.CONF")), "\n")  
      sList = Split(sRawList, "\n")
      'PRINT sRawList & "srawlist " & sList.Count
        FOR i = 0 TO sList.count - 1
              'sLine = Trim(sList[i])
              'PRINT sList[i]
        IF Left(sList[i], Len("BULK")) = "BULK" THEN 
                
          sTrimmed = Right(sList[i], Len(sList[i]) - InStr(sList[i], "\'"))
          sTrimmed = Left(sTrimmed, InStr(sTrimmed, "\'") - 1)
          sLineArr = Split(sTrimmed, ":")
            sBulkPath = sLineArr[0]
            vBulkSize = sLineArr[1]
            sBulkDesc = sLineArr[2]
            'PRINT sBulkPath & vBulkSize & sBulkDesc
            FrmInstallSys.pbInstallProg.Value = 0
            INC ClsGlobal.iPkgNum
            SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO vTargetSize
                PRINT "installing " & sBulkPath  
                FrmInstallSys.tlCurrPkg.Text = ("Installing") & Space(1) & sBulkDesc & " ..."      
                'ME.BULK_INSTALL(ClsGlobal.sSourceMnt &/ "veclinux" &/ sBulkPath)
                hproc = SHELL "lzmadec <" & ClsGlobal.sSourceMnt &/ "veclinux" &/ sBulkPath & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\' 2> /tmp/installdump" 'FOR READ
                PRINT sBulkPath
                  WAIT 1
                    IF hproc.State = Process.Running THEN 
                      REPEAT 
                        WAIT 2
                          ME.UPDATE_STEP_PROGRESS(CFloat(vTargetSize), CFloat(vBulkSize), ClsGlobal.iPkgNum)
                          FrmInstallSys.pbInstallProg2.Value = (FrmInstallSys.pbInstallProg2.Value + (ClsGlobal.fPbInc - (ClsGlobal.fPbInc * FrmInstallSys.pbInstallProg.Value)) / 100)
                      UNTIL 
                        hproc.State = Process.Stopped
                        'error check
                    END IF
                END IF  
        FrmInstallSys.pbInstallProg.Value = 1
        WAIT 
        FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(ClsGlobal.iPkgCnt, ClsGlobal.iPkgNum)          
        
      NEXT 
'RETURN 
 IF InStr(sDump, "FAILED") > 0 THEN 
                RETURN 1
              ELSE 
                RETURN 0
              END IF
  
END


PUBLIC SUB BULK_INSTALL(sPath_to_bulk AS String)
    sDump = ""
    sErr = ""
  
    hproc = SHELL "lzmadec <" & sPath_to_bulk & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\' 2> /tmp/installdump" WAIT  'FOR READ  
      WAIT 
      sDump = File.Load("/tmp/installdump")
        IF InStr(sDump, "FAILED") > 0 THEN 
          Message.Error(("Error occurred while installing") & Space(1) & sPath_to_bulk)
          RETURN 
        END IF
        
END


PUBLIC SUB PACKAGE_INSTALL(sPath_To_Package AS String)
  
  sDump = ""
  SHELL "echo \"\" > /tmp/installdump" WAIT 
  sErr = ""
  INC ClsGlobal.iPkgNum
  'hproc = SHELL "install-pkg " & sPath_To_Package & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ 
  'IF Right(sPath_To_Package, 3) LIKE "t?z" THEN 
  IF File.Ext(sPath_To_Package) LIKE "t?z" THEN 
    'SHELL "echo \"\" > /tmp/installdump"
  hproc = SHELL " installpkg " & sPath_To_Package & " -R " & ClsGlobal.sTargetMnt & " || echo \'FAILED\' 2> /tmp/installdump" WAIT 'FOR READ   
        ' WAIT 
        ' sDump = File.Load("/tmp/installdump")
        '   IF InStr(sDump, "FAILED") > 0 THEN 
        '     Message.Error(("Unable to install") & Space(1) & sPath_To_Package)
        '   END IF
  ENDIF 
END


PUBLIC SUB PERFORM_FULL_INSTALL_OLD() AS Integer
  
  'Will need to read SETUP.CONF to determine what to do here
  
  DIM sFile AS String[]
  DIM sEntry AS String[]
  DIM stlzList AS String[]
  DIM sTlz AS String
  DIM sPak AS String
  DIM sPakPath AS String
  DIM sPakSize AS Variant
  DIM sTargetSize AS Variant
  DIM iTotalSize AS Integer
  DIM iCurrSize AS Variant
  DIM sPakDesc AS String
  DIM i AS Integer
  DIM ii AS Integer
  DIM sLine AS String
  DIM sBulkPath AS String
  DIM sConfPath AS String
  DIM sOptPkgPath AS String
  DIM iVal AS Float  
  DIM sBasePath AS String = ClsGlobal.sSourceMnt &/ "veclinux"
      
      WITH FrmInstallSys
        .Resize(FMain.pnlWinHost.Width, FMain.pnlWinHost.Height)
      END WITH 
  ClsGlobal.iPkgCnt = MdlSetup.CALCULATE_PACKAGE_COUNT(FALSE)
    'Message.Info("Total packages = " & iPkgCnt)
  'RETURN 
  ' make sure the progress is revealed at the main window
    WITH FMain
    .tvPlan["Inst1"].Picture = MdlCore.sDonePic
    .tvPlan["Inst2"].Selected = TRUE
    .tvPlan["Inst2"].Picture = MdlCore.sNowPic
    END WITH   
  
  MdlSetup.SHOW_PROGRESS_CONTROLS()
  FrmInstallSys.tlBanner.Text = ("Vectorlinux is now being installed. Please wait...")
  ClsGlobal.sTargetMnt = "/mnt/target"
    sFile = Split(File.Load(Temp$("SETUP.CONF")), "\n")
      FOR i = 0 TO sFile.count - 1
        sLine = Trim(sFile[i])
          IF Left(sLine, Len("BULK") + 1) LIKE "BULK" & "*[0-9]*" THEN 
            sLine = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
            sLine = Left(sLine, Len(sLine) - 1)
              sPak = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
              sPak = Left(sPak, Len(sPak) - 1)
              sEntry = Split(sPak, ":")
                sPakPath = sEntry[0]
                sPakSize = sEntry[1]
                sPakDesc = sEntry[2]
                  'PRINT sBasePath &/ sPakPath & " = " & sPakDesc & " size= " & CStr(sPakSize)    
                      ' figure out the sizing and the progrss meter
                        SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
                          'Message(CStr(sTargetSize))
                          sTargetSize = Trim(CStr(sTargetSize))
                          sPakSize = Trim(CStr(sPakSize)) '                 
                          
                        'RETURN 
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sPakDesc & " ..."
                FrmInstallSys.pbInstallProg.Value = 0.0
                
                PRINT "Installing " & sPakDesc & " Total size (KB) = " & CStr(sPakSize)
                sDump = ""
                sErr = ""
                  MdlCore.LOCK_GUI()
                  'inc iPkgNum
              hproc = SHELL "lzmadec <" & sBasePath &/ sPakPath & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\' 2> /tmp/installdump" 'FOR READ
              
                WAIT 2
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 2
                           UPDATE_STEP_PROGRESS(sTargetSize, sPakSize, ClsGlobal.iPkgNum)                           
                    UNTIL 
                      hproc.State = Process.Stopped
                          ' error check
                            sDump = File.Load("/tmp/installdump")
                            IF InStr(sDump, "FAILED") > 0 THEN 
                              Message.Error(("There has been an error extracting") & Space(1) & sPakDesc & gb.NewLine &
                              "<b>ERROR</b>" & gb.NewLine &
                              sErr)
                              RETURN 1
                            ELSE 
                              FrmInstallSys.pbInstallProg.Value = 1                              
                  END IF
                PRINT sPak & " is installed... "
                INC ClsGlobal.iPkgNum
                              FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(ClsGlobal.iPkgCnt, ClsGlobal.iPkgNum)
                            END IF
           'PRINT "Needs to install " & sPak
          END IF
    NEXT 
  FrmInstallSys.tlBanner.Text = ("Finished intalling Bulks")
  
        ' now to the packages individually
        ' FrmInstallSys.tlBanner.Text = "Installing additional software."
  ' ME.INSTALL_PACKAGES    
END


PUBLIC SUB UPDATE_STEP_PROGRESS(sTargetSize AS Float, sPakSize AS Float, iCurrPkg AS Integer)
  
  DIM iMBProgress AS Float
  DIM ipct AS Float
  DIM iMinpct AS Float = ".01"
  DIM iMaxpct AS Float = ".99"
  DIM iVal AS Float
  DIM iProgress AS Float
  DIM iCurrSize AS Variant
  DIM fcur, fRet AS Float
  DIM fbulk AS Float = 0.6
   
  SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO iCurrSize
  iCurrSize = Trim(CStr(iCurrSize))
  iProgress = CInt(iCurrSize - sTargetSize)
  iMBProgress = iProgress / 1024
  IF iMBProgress > CFloat(sPakSize) THEN 
    iVal = iMaxpct
  ELSE 
    ipct = 100 * iMBProgress
    iVal = ipct / sPakSize * 10
    IF iVal < iMinpct THEN 
      iVal = iMinpct
    ENDIF 
    IF iVal > iMaxpct THEN 
      iVal = iMaxpct
    ENDIF 
  ENDIF 
  IF iVal > FrmInstallSys.pbInstallProg.Value THEN 
    FrmInstallSys.pbInstallProg.Value = iVal
      IF iCurrPkg <= ClsGlobal.iBulkCnt THEN 
        fcur = fbulk / ClsGlobal.iBulkCnt
        fRet = (iCurrPkg - 1) * fcur
        fRet = Round(fRet, -2)
        FrmInstallSys.pbInstallProg2.Value = ((iVal * fcur) + fRet)
      ENDIF 
  END IF
  
  'PRINT CStr(iCurrSize) & "/" & CStr(sTargetSize + sPakSize) & " = " & iVal & "%"
END


PUBLIC FUNCTION INSTALL_PACKAGES() AS Integer
  
    DIM i AS Integer
    DIM sFile AS String[]
    DIM sLine AS String
    DIM sRawFile AS String
    DIM sTlzPath AS String
    DIM sTlzName AS String
    DIM sTlzDesc AS String
    DIM iTlzSize AS Integer
    DIM sTlzBasePath AS String = ClsGlobal.sSourceMnt &/ "packages"
    DIM sTargetSize AS Variant
    
    sRawFile = DConv(File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT"))
    
      sFile = Split(sRawFile, "\n")
        FOR i = 0 TO sFile.count - 1
          sLine = Trim(sFile[i])
            IF Left(sLine, Len("PACKAGE NAME")) = "PACKAGE NAME" THEN 
              sTlzName = Trim(Right(sLine, Len(sLine) - InStr(sLine, ":")))
              sTlzPath = Trim(Right(sFile[i + 1], Len(sFile[i + 1]) - InStr(sFile[i + 1], ":")))
              sTlzPath = Right(sTlzPath, Len(sTlzPath) - 2) ' remove the ./ from the location line
              iTlzSize = Trim(Right(sFile[i + 3], Len(sFile[i + 3]) - InStr(sFile[i + 3], ":")))
              'iTlzSize = Left(iTlzSize, Len(iTlzSize) - 1)
              'iTlzSize = Trim(iTlzSize)
              FrmInstallSys.tlCurrPkg.Text = "Installing " & sTlzName & " ..."
              FrmInstallSys.pbInstallProg.Value = 0.0
              
              PRINT " Install " & sTlzBasePath &/ sTlzPath &/ sTlzName 
                  ' install each package
               SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
               sTargetSize = Trim(CStr(sTargetSize))
              SHELL "echo \"\" > /tmp/installdump" WAIT 
              sDump = ""
              sErr = ""
              'hproc = SHELL "install-pkg " & sTlzBasePath &/ sTlzPath &/ sTlzName & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
              hproc = SHELL "installpkg " & sTlzBasePath &/ sTlzPath &/ sTlzName & " -R " & ClsGlobal.sTargetMnt & " || echo \'FAILED\' 2> /tmp/installdump" WAIT 'FOR READ
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 1
                      UPDATE_STEP_PROGRESS(sTargetSize, iTlzSize, ClsGlobal.iPkgNum)
                      
                          ' figure out the progress again

                    UNTIL 
                      hproc.State = Process.Stopped
                        sDump = File.Load("/tmp/installdump")
                        
                          IF InStr(sDump, "FAILED") > 0 THEN 
                            ERROR 
                            RETURN 1
                          ELSE 
                            IF FrmInstallSys.pbInstallProg.Value <> 1 THEN 
                              FrmInstallSys.pbInstallProg.Value = 1
                            END IF
                          END IF
                  END IF
                  INC ClsGlobal.iPkgNum
                  FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(ClsGlobal.iPkgCnt, ClsGlobal.iPkgNum)
          END IF
      NEXT 
            
    ' DONE INSTALLING SOFTWARE. 
      'Message.Info("Installation complete. Ready for configuration"
      FrmInstallSys.tlBanner.Text = ("Installation phase complete. Ready for configuration")
      FrmInstallSys.pbInstallProg.Value = 1
      MdlCore.unlock_gui()      
      FrmInstallSys.tlBanner.Text = ("Installing default system configuration and required software.")
END


PUBLIC FUNCTION INSTALL_REQUIRED_PACKAGES() AS Integer
  
    DIM i, ii AS Integer
    DIM sList AS String[]
    DIM sRawList AS String
    'DIM sRawFile AS String
    
    DIM sTlzPath AS String
    DIM sTlzName AS String
    DIM sTlzDesc AS String
    DIM sTlzBasePath AS String = ClsGlobal.sSourceMnt &/ "packages"
    DIM iTlzTotal AS Integer = 0
    DIM iCurrTlz AS Integer '= 0
    MdlCore.LOCK_GUI()
    'SHELL "echo \"\" > /tmp/installdump" WAIT 
    'sRawFile = DConv(File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT"))
    
      '/ NO PACKAGE SIZE DATA AVAILABLE FOR PACKAGES/REQUIRED.
          'PROGRESS CALCULATION IS BASED ON iCurrTlz/ITlzTotal
          
     
      SHELL "ls " & ClsGlobal.sSourceMnt &/ "packages" &/ "required" &/ "*.t?z " TO sRawList
      sRawList = Trim(sRawList)
        sList = Split(sRawList, "\n")
            iTlzTotal = sList.Count - 1
              'Message(iTlzTotal)
          FOR i = 0 TO sList.count - 1
            sTlzPath = Trim(sList[i])
            sTlzName = File.Name(sTlzPath)
            FrmInstallSys.pbInstallProg.Value = i / iTlzTotal 
              ' clear the dump
              'SHELL "echo \' \' > /tmp/installdump" WAIT 
              'EXEC "echo", " ", "/tmp/installdump"] WAIT 
              IF i > iTlzTotal THEN 
                ii = iTlzTotal
              ELSE 
                ii = (i + 1)
              ENDIF 
              FrmInstallSys.tlCurrPkg.Text = ("Installing Required Package ...") & ii & " of " & (iTlzTotal + 1) 'sTlzName
              'hproc = SHELL "installpkg " & sTlzPath & " -R " & ClsGlobal.sTargetMnt & " || echo \'FAILED\'"
              hproc = EXEC ["installpkg", sTlzPath, "-R", ClsGlobal.sTargetMnt]
              'hproc = exec ["installpkg",sTlzPath,"-R",ClsGlobal.sTargetMnt
                WAIT 
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 
                  UNTIL hproc.State = Process.Stopped
                END IF
                  sDump = ""
                  'sDump = File.Load("/tmp/installdump")
                   ' IF InStr(sDUmp, "FAILED") > 0 THEN 
                   IF hproc.Value > 0 THEN 
                        Message.Error(sTlzName & Space(1) & ("Failed to install"))
                        
                      RETURN 1
                    END IF
            
                 
            
            INC ClsGlobal.iPkgNum
            FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(ClsGlobal.iPkgTot, ClsGlobal.iPkgNum)
            
            
            'Message(sTlzPath & "<br>" & sTlzName)
          NEXT 
  
END


PUBLIC FUNCTION INSTALL_CONFIG_PACKAGES() AS Integer
  
  DIM sRawList AS String
  DIM sList AS String[]
  DIM sCount AS String[]
  DIM sTrimmed AS String
  DIM sLineArr AS String[]
  DIM sBulkPath AS String
  DIM vBulkSize AS Variant
  DIM sBulkDesc AS String
  DIM vTargetSize AS Variant
  DIM i AS Integer
  'DIM sFile AS String = File.Load(ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF")
  DIM sLine AS String
  
  SHELL "echo \"\" > /tmp/installdump" WAIT 
  'PRINT "Installing final system configuration"
  SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF" & " | grep ^CONF" TO sRawList
      sList = Split(sRawList, "\n")
      'PRINT sRawList & "srawlist " & sList.Count
        FOR i = 0 TO sList.count - 1
              'sLine = Trim(sList[i])
              'PRINT sList[i]
        IF Left(sList[i], Len("CONF")) = "CONF" THEN 
                
          sTrimmed = Right(sList[i], Len(sList[i]) - InStr(sList[i], "\'"))
          sTrimmed = Left(sTrimmed, InStr(sTrimmed, "\'") - 1)
          sLineArr = Split(sTrimmed, ":")
            sBulkPath = sLineArr[0]
            vBulkSize = sLineArr[1]
            sBulkDesc = sLineArr[2]
            'PRINT sBulkPath & vBulkSize & sBulkDesc
            FrmInstallSys.pbInstallProg.Value = 0
            INC ClsGlobal.iPkgNum
            SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO vTargetSize
                PRINT "installing " & sBulkPath  
                FrmInstallSys.tlCurrPkg.Text = ("Installing") & Space(1) & sBulkDesc & " ..."      
                'ME.BULK_INSTALL(ClsGlobal.sSourceMnt &/ "veclinux" &/ sBulkPath)
                hproc = SHELL "lzmadec <" & ClsGlobal.sSourceMnt &/ "veclinux" &/ sBulkPath & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\' 2> /tmp/installdump" 'FOR READ
                PRINT sBulkPath
                  WAIT 1
                    IF hproc.State = Process.Running THEN 
                      REPEAT 
                        WAIT 2
                          ME.UPDATE_STEP_PROGRESS(CFloat(vTargetSize), CFloat(vBulkSize), ClsGlobal.iPkgNum)
                          FrmInstallSys.pbInstallProg2.Value = (FrmInstallSys.pbInstallProg2.Value + (ClsGlobal.fPbInc - (ClsGlobal.fPbInc * FrmInstallSys.pbInstallProg.Value)) / 100)
                      UNTIL 
                        hproc.State = Process.Stopped
                        'error check
                    END IF
                END IF  
        FrmInstallSys.pbInstallProg.Value = 1
        WAIT
        'FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(ClsGlobal.iPkgCnt, ClsGlobal.iPkgNum)
   NEXT 
END



PUBLIC SUB process_error(msg AS String)

'  sErr = sErr & gb.NewLine & sErr
  PRINT MSG
END 
