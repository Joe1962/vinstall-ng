' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.
PRIVATE sMountedList AS String
PUBLIC objProgs AS Object[]
PUBLIC objSliders AS Object[]
PUBLIC objTls AS Object[]
PUBLIC sResizableList AS String[]
PUBLIC objContainters AS Object[]
PUBLIC objRbs AS Object[]
PRIVATE picDrive AS Picture
PRIVATE myProgs AS Object[]

PUBLIC sPartitionToShrink AS String
PUBLIC lMBAmmountToUseForVL AS Long


PUBLIC FUNCTION PERFORM_AUTO_PARTITION_FROM_FREE_SPACE(sPartition AS String) AS Integer
  
  ' trigger the automatic partitioning process.
  DIM hproc AS Process
  DIM sPartitionString, sFs, sResizeCommand, sDump, sPartPrefx AS String
  DIM sLine, partedDump, sMountDumpArr, sDumparr AS String[]
  DIM lCurrentSize AS Long
  DIM i, iPart, iPartCnt AS Integer
  DIM lEndMark AS Long
  DIM bSwapNeeded AS Boolean
  DIM sSwapPart, sRootPart, sSimulatedCommand AS String
  DIM lMbStart, lMbEnd, lMbSize, lTotalRam, lTotalSwapNeeded AS Long
  DIM bSetBoot AS Boolean
  
  lMBAmmountToUseForVL = ClsGlobal.lTotalMBforVL
  
  PRINT " --- -> Preparing to allocate " & lMBAmmountToUseForVL & " MB of space for" & Space(1) & ClsGlobal.sDistroName & Space(1) & "from " & sPartition & " <- ---"
  WAIT 1
    iPart = Right(sPartition, Len(sPartition) - Len("/dev/hda"))
      IF iPart < 10 THEN 
        sPartPrefx = " " 
      ELSE 
        sPartPrefx = ""
      END IF
      
    ' search for the partition information
      FOR i = 0 TO sResizableList.Max
        IF Left(Trim(sResizableList[i]), Len("/dev/hda1")) = Trim(sPartition) THEN 
          sPartitionString = Trim(sResizableList[i])
        END IF
      NEXT ' we got the partition string now
      
      ' Ths string is formatted like this
      ' Filesystem    Type   1M-blocks      Used Available Use% Mounted on
      
      ' split it in spaces
      sLine = Split(sPartitionString, " ")
        sFs = Trim(sLine[1])
        lCurrentSize = sLine[2]
      
      IF lMBAmmountToUseForVL <= 0 THEN 
        Message.Error("I dont know how much space to use for VL")
          RETURN 
      END IF
      
      SELECT CASE sFs
        CASE "ntfs", "NTFS", "HPFS/NTFS"
          'sResizeCommand = "ntfsresize -s " & (lCurrentSize - lMBAmmountToUseForVL) & "m" & Space(1) & sPartition
          sResizeCommand = "ntfsresize -P --force --force " & spartition & Space(1) & "-s " & (lCurrentSize - lMBAmmountToUseForVL) & "M"
          sSimulatedCommand = "ntfsresize -P --force --force " & spartition & Space(1) & "-s " & (lCurrentSize - lMBAmmountToUseForVL) & "M --no-action"
          
            SHELL "parted " & Left(spartition, Len("/dev/hda")) & " print | grep \"^ " & Right(spartition, Len(spartition) - Len("/dev/hda")) & "\"| tr -s \' \',\"\"" TO sDump
              sDump = Trim(sDump)
              'Message(sDump)
              'sDumparr = Split(sDump, " ")
              
                
                IF InStr(sDump, " boot") THEN 
                
                    bSetBoot = TRUE
                    PRINT " ----- Boot flag detected on " & spartition
               
                END IF
                
              
            
        CASE "ext2", "ext3", "*fat*", "hfsx", "hfs+", "hfs", "linux-swap", "vfat", "VFAT"
          SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print | tr -s \' \',\"\" | grep \"^" & sPartPrefx & iPart & "\"" TO sDump
            sDump = Trim(sDump)
            'Number Start End     Size    Type   File system Flags
            '1    0.03MB 12256MB 12256MB primary reiserfs 
            partedDump = Split(sDump, " ")
            
            'RETURN 1
            lEndMark = Left(partedDump[2], Len(partedDump[2]) - 2)
            sResizeCommand = "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb -s \"resize " & iPart & Space(1) & Trim(partedDump[1]) & Space(1) & (lEndMark - lMBAmmountToUseForVL) & "m\""
        CASE "reiserfs"
           'r resize_reiserfs -s -1G /dev/hda8 ( see man resize_reiserfs )
           sResizeCommand = "echo \"y\" | resize_reiserfs -fq -s -" & lMBAmmountToUseForVL & "M" & Space(1) & sPartition
           PRINT "DEBUG: " & sResizeCommand
           
        CASE ELSE 
          Message.Error("I dont know how to resize a partition type " & sFs)
          RETURN 1
      END SELECT 
      
  
  'Message(sResizeCommand)
      ' MAKE SURE THE PARTITION IS NOT MOUNTED BEFORE PROCEEDING
      SHELL "mount | grep ^" & sPartition TO sDump
      sDump = Trim(sDump)
      sMountDumpArr = Split(sDump, "\n")
        FOR i = 0 TO sMountDumpArr.Max
          SHELL "umount -f " & sPartition
        NEXT 
  
  ' Just to make sure
    SHELL "mount | grep ^" & sPartition TO sDump
      sDump = Trim(sDump)
        IF Len(sDump) > 0 THEN 
          Message.Error(sPartition & Space(1)("is currently being used. Unable to umount it.") & "<br>" &
          ("Try another partitioning method"))
          RETURN 1
        END IF
    
          
          'if ntfs... then run a simulation
          IF sfs LIKE "ntfs" THEN 
            PRINT " ---\\-> Running ntfs resize simulation "             
              hproc = SHELL sSimulatedCommand WAIT 
                IF hproc.Value > 0 THEN 
                  Message.Error(("Simulated resize of your ntfs partition") & Space(1) & "(" & spartition & ")" & "<br>" &
                  ("It is not safe to perform this operation... Please use another partitioning method"))
                  RETURN hproc.Value
                END IF
                
              ' we need to use sectors as the units for this to work... otherwise we may lose some data
                
                
            PRINT " ---\\__ Running real resize operation"
          END IF 
                  
              
  ' run the actual command
  'DEBUG sResizeCommand
  'RETURN 1
    DEBUG sResizeCommand
    hproc = SHELL sResizeCommand WAIT 
      PRINT " ---\\--> Shinking partition " & spartition
      IF hproc.Value > 0 THEN 
        RETURN hproc.Value
        
      END IF
      PRINT "Done"
      
      'DEBUG "done resizing"
      '
      'RETURN 1
      
      
      IF sFs LIKE "ntfs" THEN 
        PRINT " ----|=- Re-creating ntfs filesystem"
          hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " rm " & Right(sPartition, Len(spartition) - Len("/dev/hda")) WAIT ' remove the filesystem
            IF hproc.Value > 0 THEN 
              Message.Error(("Error deleting the ntfs filesytem"))
              RETURN hproc.Value
            END IF
          hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart primary ntfs 0M " & (lEndMark - lMBAmmountToUseForVL) & "M\"" WAIT ' re-create the shrunken fs
            IF hproc.Value > 0 THEN 
              Message.Error(("Error creating the ntfs filesystem after shrinking it"))
              RETURN hproc.Value
            END IF
          PRINT " ---- Restoring boot flag"
          hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \" set " & Right(spartition, Len(spartition) - Len("/dev/hda")) & " boot on\"" WAIT ' set the boot flag again
            IF hproc.Value > 0 THEN 
              Message("Error setting the boot flag on " & spartition)
            END IF
    ELSE IF sfs LIKE "reiserfs" THEN 
      
                    ' determine where the free space is at
            SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" | tr -s \' \',\"\"" TO sDump
            sDump = Trim(Replace(sDump, "MB", ""))
              IF sDump THEN 
            'Message(sDump)
            
            sDumparr = Split(sDump, " ")
            lMbStart = sDumparr[0]
            lMbEnd = sDumparr[1]
            lMbSize = sDumparr[2]
              ELSE 
                DEBUG "Cant find free space"
                RETURN 
              END IF
    
      hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " rm " & Right(spartition, Len(spartition) - Len("/dev/hda")) WAIT ' remove the old filesystem
        IF hproc.Value > 0 THEN 
          PRINT "Error deleting old reiserfs filesystem"
          RETURN hproc.Value
        END IF
      hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart primary reiserfs " & lMbStart & "M " & (lMbEnd - lMBAmmountToUseForVL) & "M\"" WAIT ' re-create the new fs"
          DEBUG "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart primary reiserfs " & lMbStart & "M " & (lMbEnd - lMBAmmountToUseForVL) & "M\"" ' re-create the new fs"
        IF hproc.Value > 0 THEN 
          PRINT "Error restoring reiserfs filesystem."
          RETURN hproc.Value
        END IF
      
            
          
    END IF
    
          
      
  ' create new partitions now that we're here ============================================================================================
    ' do we need to create a swap partition?
    ' the global partitions must be set as "/dev/hda1-SIZE_IN_GB"
    
    
      SHELL "probepart | grep -i \"linux swap\"" TO sDump
        sDump = Trim(sDump)
          IF sDump THEN 
            bSwapNeeded = FALSE ' found a swap partition
            sDumparr = Split(sDump, "\n")
            sLine = Split(sDumparr[0], " ")
            sSwapPart = Trim(sLine[0])
            'SHELL "parted " & lef & " unit GB print | grep \"^ " & sNum & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump        
            SHELL "parted " & Left(sSwapPart, Len("/dev/hda")) & " unit GB print | grep \"^ " & Right(sSwapPart, Len(sSwapPart) - Len("/dev/hda")) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
              sDump = Trim(sDump)
              PRINT " --- . Use existing swap partition at " & sSwapPart
              sSwapPart = sSwapPart & "-" & sDump 
            
          ELSE 
            bSwapNeeded = TRUE
            
            
          END IF
         
         ' determine how many partitions are present in the drive
          SHELL "probepart | grep \"^" & Left(sPartition, Len("/dev/hda")) & "\" |wc -l" TO sDump
            sDump = Trim(sDump)
            iPartCnt = sDump
          
                      ' determine where the free space is at
            SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" | tr -s \' \',\"\"" TO sDump
            sDump = Trim(Replace(sDump, "MB", ""))
            Message(sDump)
            IF Len(sDump) <= 0 THEN RETURN 1
            sDumparr = Split(sDump, " ")
            lMbStart = sDumparr[0]
            lMbEnd = sDumparr[1]
            lMbSize = sDumparr[2]
            
         ' determine ammount of ram available
                  SHELL "free -m | grep \"^Mem:\" | tr -s \' \',\"\" | cut -f2 -d \' \'" TO sDump
                    lTotalRam = sDump
                      IF lTotalRam <= 512 THEN 
                        lTotalSwapNeeded = (lTotalRam * 2)
                      ELSE 
                        lTotalSwapNeeded = lTotalRam
                      END IF
            
          
    IF iPartCnt <= 2 THEN 
      IF bSwapNeeded = FALSE THEN 
        ' only create the / partition
          PRINT " ---\\__ Create / partition @ " & Left(sPartition, Len("/dev/hda")) & (iPartCnt + 1) & " size = " & lMbSize & " MB with reiserfs as filesytem"
          PRINT "DEBUG: " & "parted " & Left(sPartition, Len("/dev/hda")) & " -s \"mkpart primary reiserfs " & lMbStart & "mb " & lMbEnd & "mb\""
          hproc = SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " -s \"mkpart primary reiserfs " & lMbStart & "mb " & lMbEnd & "mb\"" WAIT 
            IF hproc.Value > 0 THEN 
              RETURN hproc.Value
            END IF
          SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit GB print | grep \"^ " & (iPartCnt + 1) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
          hproc = SHELL "mkfs.reiserfs -q " & Left(spartition, Len("/dev/hda")) & (iPartCnt + 1) WAIT
           
          sRootPart = Left(sPartition, Len("/dev/hda")) & (iPartCnt + 1) & "-" & sDump
      ELSE 
        ' create root and swap
          SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart extended " & lMbSize & "mb " & lMbEnd & "mb\"" WAIT 
           ' ^ creates a wrapper around the unpartitioned space to give us room for new partitions (logical type)
              ' **********  need to read new space location and dimensions ***************
          SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" tr -s \' \',\"\"" TO sDump
            sDump = Trim(Replace(sDump, "MB", ""))
            sDumparr = Split(sDump, " ")
            lMbStart = sDumparr[0]
            lMbEnd = sDumparr[1]
            lMbSize = sDumparr[2]
      ' swap partition will be iPartcnt + 2 here (because the extended is iPartcnt +1)
      ' / partition (if needed) will be iPartcnt + 3
              
                
                  ' SHELL "parted " & Trim(sdrive) & " mkpart logical linux-swap " & sFreeStart & " " & sFreeEnd WAIT 
                  hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " mkpart logical linux-swap " & lMbStart & "MB " & (lMbStart + lTotalSwapNeeded) & "MB" WAIT 
                    IF hproc.Value > 0 THEN RETURN hproc.Value
                    PRINT " ---\\___ Created swap partition " & Left(spartition, Len("/dev/hda")) & (iPartCnt + 2) & " size = " & lTotalSwapNeeded & "MB"
                      ' register the new swap partition to the global class
                      SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit GB print | grep \"^ " & (iPartCnt + 2) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
                        sSwapPart = Left(spartition, Len("/dev/hda")) & (iPartCnt + 2) & "-" & sDump
                    
             ' YET AGAIN
             SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" tr -s \' \',\"\"" TO sDump
                        sDump = Trim(Replace(sDump, "MB", ""))
                        sDumparr = Split(sDump, " ")
                        lMbStart = sDumparr[0]
                        lMbEnd = sDumparr[1]
                        lMbSize = sDumparr[2]
                  hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart logical reiserfs " & lMbStart & "MB " & lMbEnd & "MB\"" WAIT 
                    IF hproc.Value > 0 THEN RETURN hproc.Value
                  PRINT " ---\\___ Created / partition " & Left(spartition, Len("/dev/hda")) & (iPartCnt + 3) & " size = " & lMbSize & "MB"
                  SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit GB print | grep \"^ " & (iPartCnt + 3) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
                  sRootPart = Left(spartition, Len("/dev/hda")) & (iPartCnt + 3) & "-" & sDump
          
      END IF
          
          
          
      
    ELSE  
      ' we will create an extended partition wich will be number iPartCnt +1
        SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart extended " & lMbStart & "mb " & lMbEnd & "mb\"" WAIT 
        ' ^ creates a wrapper around the unpartitioned space to give us room for new partitions (logical type)
              ' **********  need to read new space location and dimensions ***************
          SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" tr -s \' \',\"\"" TO sDump
            sDump = Trim(Replace(sDump, "MB", ""))
            sDumparr = Split(sDump, " ")
            lMbStart = sDumparr[0]
            lMbEnd = sDumparr[1]
            lMbSize = sDumparr[2]
      ' swap partition will be iPartcnt + 2 here (because the extended is iPartcnt +1)
      ' / partition (if needed) will be iPartcnt + 3
              IF bSwapNeeded = TRUE THEN 
                
                  ' SHELL "parted " & Trim(sdrive) & " mkpart logical linux-swap " & sFreeStart & " " & sFreeEnd WAIT 
                  hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " mkpart logical linux-swap " & lMbStart & "MB " & (lMbStart + lTotalSwapNeeded) & "MB" WAIT 
                    IF hproc.Value > 0 THEN RETURN hproc.Value
                    PRINT " ---\\___ Created swap partition " & Left(spartition, Len("/dev/hda")) & (iPartCnt + 2) & " size = " & lTotalSwapNeeded & "MB"
                      ' register the new swap partition to the global class
                      SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit GB print | grep \"^ " & (iPartCnt + 2) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
                        sSwapPart = Left(spartition, Len("/dev/hda")) & (iPartCnt + 2) & "-" & sDump
                    
             ' YET AGAIN
             SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" tr -s \' \',\"\"" TO sDump
                        sDump = Trim(Replace(sDump, "MB", ""))
                        sDumparr = Split(sDump, " ")
                        lMbStart = sDumparr[0]
                        lMbEnd = sDumparr[1]
                        lMbSize = sDumparr[2]
                  hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart logical reiserfs " & lMbStart & "MB " & lMbEnd & "MB\"" WAIT 
                    IF hproc.Value > 0 THEN RETURN hproc.Value
                  PRINT " ---\\___ Created / partition " & Left(spartition, Len("/dev/hda")) & (iPartCnt + 3) & " size = " & lMbSize & "MB"
                  SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit GB print | grep \"^ " & (iPartCnt + 3) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
                  sRootPart = Left(spartition, Len("/dev/hda")) & (iPartCnt + 3) & "-" & sDump
          ELSE ' no swap needed
              
              SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit mb print free | grep -i \"free space\" tr -s \' \',\"\"" TO sDump
                        sDump = Trim(Replace(sDump, "MB", ""))
                        sDumparr = Split(sDump, " ")
                        lMbStart = sDumparr[0]
                        lMbEnd = sDumparr[1]
                        lMbSize = sDumparr[2]
                  hproc = SHELL "parted " & Left(spartition, Len("/dev/hda")) & " -s \"mkpart logical reiserfs " & lMbStart & "MB " & lMbEnd & "MB\"" WAIT 
                    IF hproc.Value > 0 THEN RETURN hproc.Value
                  PRINT " ---\\___ Created / partition " & Left(spartition, Len("/dev/hda")) & (iPartCnt + 2) & " size = " & lMbSize & "MB"
                  SHELL "parted " & Left(sPartition, Len("/dev/hda")) & " unit GB print | grep \"^ " & (iPartCnt + 2) & "\" | tr -s \' \',\"\" | cut -f 5 -d \' \'" TO sDump
                  sRootPart = Left(spartition, Len("/dev/hda")) & (iPartCnt + 2) & "-" & sDump
                  
                               
              END IF
    END IF
              
      
      ClsGlobal.sTargetRoot = Trim(sRootPart)
      ClsGlobal.sTargetSwap = Trim(sSwapPart)
  
  
END




PUBLIC SUB DISPLAY_PARTITIONS_WITH_FREE_SPACE(hostContainer AS Container)
  
  DIM sDump, sPreMountList, sDfDump, sDrives, sPartition, sPartShort AS String
  DIM sResults, sDumparr, sLineArr AS String[]
  DIM sPost, sFinalList AS String
  DIM lFreeMB, lTotalMB, lUsedMB AS Long
  DIM i, n AS Integer
  DIM rb AS RadioButton
  DIM pb AS ProgressBar
  DIM sl AS Slider
  DIM hb AS hpanel
  DIM tl AS TextLabel
  DIM hr AS Separator
  DIM picb AS PictureBox
  DIM hobox AS Panel
  DIM sFs AS String
  DIM bgc AS Integer
  
  objProgs = NEW Object[]
  objSliders = NEW Object[]
  sResizableList = NEW String[]
  objTls = NEW Object[]
  objRbs = NEW Object[]
  objContainters = NEW Object[]
  myProgs = NEW Object[]

  
  picDrive = Picture.Load("images/hdd.png")
  PRINT " ---\\_ Shrink existing partitions to make room for VL"  

  WAIT 
    
  SHELL "df -Th | grep \"^/dev/\" | cut -f 1 -d \' \'" TO sPreMountList '| tr -s \' \',\"\"" TO sPreMountList
  'Message(sPreMountList)
    sDumparr = Split(sPreMountList, "\n")
      FOR i = 0 TO sDumparr.Max
        IF InStr(sFinalList, Trim(sDumparr[i])) = FALSE THEN 
          SHELL "df -Tm | grep \"" & Trim(sDumparr[i]) & "\" | tr -s \' \', \"\"" TO sDump
          sFinalList = sFinalList & sDump
        END IF
      NEXT        
  
  
  SHELL "probepart | grep \"^/dev/\" | tr -s \' \',\"\" | cut -f 1 -d \' \'" TO sDump
  'Message(sDump)
    sDump = Trim(sDump)
    sDumparr = Split(sDump, "\n")
      FOR i = 0 TO sDumparr.Max
        sPartition = Trim(sDumparr[i])
        sPartShort = Right(sPartition, Len(sPartition) - RInStr(sPartition, "/"))
        'Message(sPartShort)
        'sMountedList = sMountedList & sPartition & " "
        'IF InStr(sMountedList, sPartition) = FALSE THEN 
        'IF NOT InStr(Trim(sPreMountList), Trim(sPartition)) THEN 
        'IF InStr(Trim(sPreMountList), Trim(sPartition)) = FALSE THEN 
        IF InStr(sFinalList, Trim(sPartition)) = FALSE THEN 
          'Message(sPartition & " is not in the pre-mounted list")
          SHELL "mkdir -p /mnt" &/ sPartShort & " 2> /dev/null" WAIT 
          SHELL "mount -o ro " & sPartition & Space(1) & "/mnt" &/ sPartShort & " 2> /dev/null" WAIT 
          'SHELL "df -Th | grep \"^" & sPartition & "\" | head -n 1 | tr -s \' \',\"\"" TO sDump
          SHELL "df -Tm /mnt" &/ sPartShort & " | grep \"^/dev/\"| tr -s \' \',\"\"" TO sDump
          'Message(sDump)
          'sPost = sPost & sDump
          IF InStr(sFinalList, sDump) = FALSE THEN 
          IF InStr(sDump, ClsGlobal.sSourceAddr) = FALSE THEN 
          sFinalList = sFinalList & sDump
          END IF
          END IF
          SHELL "umount -f /mnt" &/ sPartShort & " 2> /dev/null" WAIT 
          
        END IF
          
      NEXT 
      
  
     'Message(sFinalList)
     sFinalList = Trim(sFinalList)
     sResults = Split(sFinalList, "\n")
      FOR i = 0 TO sResults.Max
        ' Message(Trim(sResults[i]))
        sLineArr = Split(Trim(sResults[i]), " ")
        sFs = Trim(sLineArr[1])
        lTotalMB = Trim(sLineArr[2])
        lUsedMB = Trim(sLineArr[3])        
        lFreeMB = Trim(sLineArr[4])
        'Message(sLineArr[0] & Space(1) & "fREE SPACE " & sLineArr[4] & " Mb") 
        
        IF lFreeMB >= 10240 THEN ' only if free space is equal to or greater than 10GB
        'Message(sLineArr[1])
          'IF Trim(sLineArr[1]) <> "*xfs*" OR Trim(sLineArr[1]) <> "reiserfs" OR Trim(sLineArr[1]) <> "*jfs*" THEN  'only if fs is not xfs or jfs
            SELECT CASE sFs ' set the background color for the existing data label
              CASE "ntfs", "NTFS"
                bgc = &h66FF66
              CASE "fat32", "FAT32", "vfat", "VFAT"
                bgc = &h33FF33
              CASE "fat16", "FAT", "FAT16"
                bgc = &h009900
              CASE "ext2", "EXT2"
                bgc = &h99CCFF
              CASE "ext3", "EXT3"
                bgc = &h336699
              CASE ELSE 
                bgc = Color.LightBackground
            END SELECT 
          IF sFS <> "reiserfs" THEN           
        sResizableList.Add(Trim(sResults[i]))
        rb = NEW RadioButton(hostContainer) AS "PartitionOptions"
          WITH rb
            .Text = Trim(sLineArr[0]) & Space(1) & "-" & Space(1) & Trim(sLineArr[4]) & Space(1) & ("MB of free space") & " [ " & sFs & " ]"
            .tag = Trim(sLineArr[0])
            .Height = 21
            .Expand = TRUE
          END WITH 
          objRbs.Add(rb)


        hb = NEW hpanel(hostContainer)
          WITH hb
            .Expand = TRUE
            .Height = 72
            .Tag = Trim(sLineArr[0])
            .Visible = FALSE
          END WITH 
          objContainters.Add(hb)
               

          
          hr = NEW Separator(hb)
            WITH hr
              .Expand = TRUE
              .Height = 8
              .tag = Trim(sLineArr[0])
            END WITH 
          hobox = NEW Panel(hb)
            WITH hobox
              .Height = 21
              '.Width = .Parent.Width / 2
              .Tag = Trim(sLineArr[0])
              .Expand = TRUE
              .Arrangement = Arrange.Row
              '.Padding = 4
              .BackColor = Color.LightBackground
            END WITH 
          'panels.Add(hobox)
          tl = NEW TextLabel(hobox)
            WITH tl
              '.BackColor = Color.SelectedBackground
              .BackColor = bgc
              .Expand = FALSE
              .Text = ("Existing Data")
              .Width = .Parent.Width / 2
              '.Width = .Parent.Width - (((lUsedMB + (4 * 1024)) + (lFreeMB / 2) / lFreeMB) / 100) * 100
              .Height = .Parent.Height
              .Alignment = Align.Center
              '.Visible = TRUE
              .tag = .Parent.Tag
            END WITH 
            myProgs.Add(tl)
          tl = NEW TextLabel(hobox)
            WITH tl
              .Text = ClsGlobal.sDistroName
              .Height = .Parent.Height
              '.Width = .Parent.Width * 0.5
              .Expand = TRUE
              '.BackColor = Color.LightBackground
              .Alignment = Align.Center
              .Tag = .Parent.Tag & "R"
            END WITH 
 
          tl = NEW TextLabel(hb)
            WITH tl
              .Text = ("Total space for") & Space(1) & ClsGlobal.sDistroName & Space(1) & ":" & Space(1)
              .Height = 21
              '.Width = .Parent.Width * 0.5
              .Alignment = Align.Left
              .BackColor = Color.Transparent
              .Expand = TRUE
              .tag = Trim(sLineArr[0])
            END WITH 
              objTls.Add(tl)
          
            
               
          sl = NEW Slider(hb) AS "Slider"
            WITH sl
              .Tag = Trim(sLineArr[0])
              .Height = 21
              .Expand = TRUE
              .Value = ((lUsedMB + (4 * 1024)) + (lFreeMB / 2) / lFreeMB) / 100
              ' IF pb.Value < 0.5 THEN 
              ' .Value = 50
              ' ELSE 
              ' .Value = (pb.Value * 100) + ((pb.Value * 100) / 2) '/ 2
              ' END IF
              '.Value = 50
            END WITH 
            objSliders.Add(sl)
          hr = NEW Separator(hb)
          WITH hr
          .Expand = TRUE
          .Height = 4
          .Tag = Trim(sLineArr[0])
          END WITH 

              
        ' hb = NEW HBox(hostContainer)
        '   WITH hb
        '     .Height = 12
        '     .Expand = TRUE
        '   END WITH 

        END IF
      END IF
      NEXT 
   
   IF objContainters.count > 0 THEN objContainters[0].visible = TRUE
    FOR EACH tl IN myProgs
      FOR EACH sl IN objSliders
        IF tl.Tag = sl.tag THEN 
        'Message(sl.value)
          tl.Width = tl.Parent.Width / 2
        END IF
      NEXT 
    NEXT 
   
    
   IF objRbs.Count <= 0 THEN ' no partitions found
    'Message.Error("No resizable partitions found")
      Step3a3.tlExp.Text = ("No resizable partitions found on your system. Please use the manual partitioning method")
      Step3a3.Refresh()
      ClsGlobal.fRunningMainForm.btnext.enabled = objRbs.count >= 1
      
   END IF
   
END



  
PUBLIC SUB Slider_change()
  
  DIM pb AS ProgressBar
  DIM hb AS Panel
  DIM fMin AS Float
  DIM fVal AS Float
  DIM i AS Integer
  DIM sMatch AS String
  DIM sLine AS String[]
  DIM lFree, lMin, ltotal, lval AS Long
  DIM tl, tlr AS TextLabel
  DIM sAllocated AS Long
  
    ' FOR EACH pb IN objProgs
    ' 
    '   IF pb.tag = LAST.tag THEN fMin = pb.Value * 100
      FOR i = 0 TO sResizableList.Max
        IF Left(Trim(sResizableList[i]), Len("/dev/hda1")) = LAST.tag THEN 
          
        'Message("fount match")
          sMatch = Trim(sResizableList[i])
          sLine = Split(sMatch, " ")
          lFree = sLine[4]
          lTotal = Trim(sLine[2])
          lMin = lFree + (4 * 1024)
          lval = (lMin / lTotal) * 10

        END IF
      NEXT 
    'NEXT 
    fmin = (LAST.value / 100)
    'Message(fmin)
    sAllocated = ltotal - (lTotal * fMin)
    LAST.tooltip = ("Select the location to which we will resize") & Space(1) & LAST.tag
    FOR EACH tl IN objTls
      IF tl.Tag = LAST.tag THEN 
      
        tl.Text = ("Total space for") & ClsGlobal.sDistroName & ":" & Space(1) & (100 - LAST.Value) & "%" & Space(1) & "-" & " ( " & sAllocated & " MB )"
      'lMBAmmountToUseForVL = sAllocated  
      ClsGlobal.lTotalMBforVL = sAllocated
      END IF
    NEXT 

  FOR EACH tl IN myProgs
    IF tl.tag = LAST.tag THEN 
      tl.Width = tl.Parent.Width * (LAST.value / 100)      
      
    END IF
      
  NEXT 

IF sAllocated <= (4 * 1024) THEN 
  Message("We need at least 4GB for" & Space(1) & ClsGlobal.sDistroName)
  STOP EVENT 
  RETURN 
END IF

  IF LAST.Value < lval THEN 
    LAST.Value = lval
      Message("This is the minimum we can resize this partition to.")
    STOP EVENT 
    RETURN 
  END IF
  
END

PUBLIC SUB PartitionOptions_Click()
  
  DIM hb AS HPanel
  FOR EACH hb IN objContainters
    IF hb.tag = LAST.tag THEN 
      hb.visible = TRUE
    ELSE 
      hb.visible = FALSE
    END IF
  NEXT 
END


