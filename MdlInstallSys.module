' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 PRIVATE hproc AS Process
 PRIVATE sDump AS String
 PRIVATE sErr AS String
 

PUBLIC FUNCTION MOUNT_DEFINED_PARTITIONS() AS Integer

 
  ' this is where we need to set the mount target
  'ClsGlobal.sTargetMnt = "/mnt/target"
  ClsGlobal.sTargetMnt = "/home/moises/mnt/target" ' just for testing now.
    IF Exist(ClsGlobal.sTargetMnt) = FALSE THEN 
      TRY MKDIR ClsGlobal.sTargetMnt
    END IF
    
    FrmInstallSys.tlCurrPkg.Text = "Mounting target partitions"
    
    SHELL "umount " & ClsGlobal.sTargetMnt WAIT 'clear the mount point
    
    '/DISABLED FOR TESTING INSTALL ONLY
    ' ' ' ' SHELL "mount " & ClsPartSel.sRoot & Space(1) & ClsGlobal.sTargetMnt & Space(1) & " -t " & ClsPartSel.fRoot WAIT  'moun the root partition first
    ' ' ' ' IF ClsPartSel.sHome THEN 
    ' ' ' '     SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "home" WAIT 
    ' ' ' '   SHELL "mount " & ClsPartSel.sHome & Space(1) & ClsGlobal.sTargetMnt &/ "home -t " & ClsPartSel.fhome WAIT 'mount the home partition if defined
      
    ' ' ' '     END IF
    IF ClsPartSel.sUsr THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "usr" WAIT 
      SHELL "mount " & ClsPartSel.sUsr & Space(1) & ClsGlobal.sTargetMnt &/ "usr -t" & ClsPartSel.fUsr WAIT ' mount the user partition
    END IF
    IF ClsPartSel.sOpt THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "opt" WAIT 
      SHELL "mount " & ClsPartSel.sOpt & Space(1) & ClsGlobal.sTargetMnt &/ "opt -t " & ClsPartSel.fOpt WAIT 'mount the opt partitiong
    END IF
    IF ClsPartSel.sVar THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "var" WAIT 
      SHELL "mount " & ClsPartSel.sVar & Space(1) & ClsGlobal.sTargetMnt &/ "var -t " & ClsPartSel.fVar WAIT 
    END IF
    IF ClsPartSel.sTmp THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "tmp" WAIT 
      SHELL "mount " & ClsPartSel.sTmp & Space(1) & ClsGlobal.sTargetMnt &/ "tmp -t " & ClsPartSel.fTmp WAIT 
    END IF
      
    ' see if there is a swap partition and use it
      IF ClsPartSel.sSwap THEN 
        SHELL "swapon -a " WAIT 
      END IF
    
    'WRITE THE NEW FSTAB NOW, RIGHT BEFORE INSTALLING PACKAGES.
    
    ME.WRITE_NEW_FSTAB() ' do this from the install form
    
    
  
  
END



PUBLIC FUNCTION WRITE_NEW_FSTAB() AS Integer
  
  DIM sEntry AS String
  DIM sPartition AS String
  DIM sMountPoint AS String
  DIM sMntOpts AS String
  DIM i AS Integer
  DIM sWinPart AS String
  DIM sWinMntPnt AS String
  DIM sFstab AS String
  
  FrmInstallSys.tlCurrPkg.Text = "Writing new /etc/fstab to system"
  
  sFstab = "# /etc/fstab: static file system information.\n" &
  "#\n" &
"#The following is an example.Please see fstab(5) for further details.\n" &
"#Please refer to mount(1) for a complete description OF mount options.\n" &
"#\n" &
"#Format:\n" &
"# < file system > < mount point > < type > < options > < dump > < pass >\n" &
"#\n" &
"#dump(8)uses the < dump > field to determine which file systems need \n" &
"# to be dumped.fsck(8)uses the < pass > column TO determine which file \n" &
"#systems need TO be checked - - the root file system should have a 1 in \n" &
"#this field, other file systems a 2, AND any file systems that should \n" &
"#not be checked(such AS MS - initrd / mnt OR NFS file systems)a 0.\n\n\n" &
"#The Linux partitions\n"

sFstab = sFstab & gb.NewLine & 
ClsPartSel.sRoot & " / " & LCase(ClsPartSel.fRoot) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fRoot)) & " 0 1" & gb.NewLine
IF ClsPartSel.sHome THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sHome & " /home " & LCase(ClsPartSel.fhome) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fhome)) & " 0 2"
END IF
IF ClsPartSel.sUsr THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sUsr & " /usr " & LCase(ClsPartSel.fUsr) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fUsr)) & " 0 2 "
END IF
IF ClsPartSel.sOpt THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sopt & " /opt " & LCase(ClsPartSel.fOpt) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fOpt)) & " 0 2 "
END IF
IF ClsPartSel.sVar THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sVar & " /var " & LCase(ClsPartSel.fVar) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fVar)) & " 0 2 "
END IF
IF ClsPartSel.sTmp THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sTmp & " /tmp " & LCase(ClsPartSel.fTmp) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fTmp)) & " 0 2 "
END IF

sFstab = sFstab & "\n\n" &
"# Shared Windows/Linux partition" &
"#/dev/hda1   /mnt/dos  msdos  umask=0   0  0 \n" &
"#/dev/hda1   /mnt/win  vfat   fmask=111,dmask=0,quiet,shortname=mixed,user  0  0 \n" &
"#/dev/hda1   /mnt/win  ntfs   umask=0   0  0\n" 
    IF ClsWinDrives.sWinDrives THEN 
      FOR i = 0 TO ClsWinDrives.sWinDrives.Count - 1
        sWinPart = Trim(Left(ClsWinDrives.sWinDrives[i], InStr(ClsWinDrives.sWinDrives[i], "|") - 1))
        sWinMntPnt = Trim(Right(ClsWinDrives.sWinDrives[i], Len(ClsWinDrives.sWinDrives[i]) - InStr(ClsWinDrives.sWinDrives[i], "|")))
        'Message("Mount " & sWinPart & " to " & sWinMntPnt)
        ' if this is right... then add it to the file
      NEXT 
    END IF

sFstab = sFstab & "\n\n" &
"# Floppy disks \n" &
"# The 'noauto' option indicates that the file system should not be mounted \n" &
"# with 'mount -a' 'user' indicates that normal users are allowed to mount \n" &
"# the file system. \n" &
"/dev/fd0   /mnt/floppy  auto  defaults,noauto,user  0 0 \n" &
"#/dev/fd1  /mnt/floppy  auto  defaults,noauto,user  0 0 \n\n" &
"# If you have a ls-120 floppy drive, it could be on /dev/hda b c d etc.\n" &
"#/dev/hdd  /mnt/ls120  auto  defaults,noauto,user  0 0 \n\n" &
"# CDROM, CDWRITER, DVD \n" &
"/dev/cdrom    /media/cdrom  iso9660  defaults,noauto,ro,user  0 0 \n" &
"#/dev/cdwriter /media/cdwriter  iso9660  defaults,noauto,rw,user  0 0 \n" &
"#/dev/dvd      /media/dvd   auto  defaults,noauto,ro,user  0 0\n\n" &
"# NFS file systems:\n" &
"#linux01.gwdg.de:/suse/6.3/i386.de  /mnt/nfs  nfs  defaults  0 0\n\n" &
"# proc file system:\n" &
"proc  /proc  proc  defaults  0 0\n\n" &
"# Unix98 devpts filesystem: \n" &
"none  /dev/pts  devpts  gid=5,mode=666  0 0\n\n" &
"# Shared memory filesystem: \n" &
"tmpfs   /dev/shm    tmpfs defaults 0  0 \n\n" &
"# Basic USB filesystem\n" &
"sysfs  /sys  sysfs  defaults  0 0\n" &
"usbfs /proc/bus/usb usbfs rw,devmode=0666 0 0\n\n" &
"# example of a VFAT USB pendrive\n" &
"#/dev/sda1  /mnt/pendrive vfat   fmask=111,dmask=0,noauto,user,quiet,shortname=mixed 0 0\n\n" &
"# Swap partitions\n" &
"# The 'sw' option means auto activating with 'swapon -a'.\n"
IF ClsPartSel.sSwap THEN 
  sFstab = sFstab & gb.NewLine &
   ClsPartSel.sSwap & Space(5) & "none" & Space(5) & "swap" & Space(5) & "sw" & Space(5) & "0" & Space(5) & "0"
END IF

sFstab = sFstab & "\n"
' Wheewww!... that's the whole fstab there... Please fix the win partitions
 
 'Message(sFstab)
 
 IF NOT ClsGlobal.sTargetMnt OR ClsGlobal.sTargetMnt = "" THEN 
  ClsGlobal.sTargetMnt = "/home/moises/mnt/target"
 END IF
 
 ';Message(ClsGlobal.sTargetMnt &/ "etc")
  ' now save the file to /etc/fstab
      IF Exist(ClsGlobal.sTargetMnt &/ "etc") = FALSE THEN 
        MKDIR ClsGlobal.sTargetMnt &/ "etc"
      END IF
    File.Save(ClsGlobal.sTargetMnt &/ "etc" &/ "fstab", SConv(sFstab))
      'CATCH 
      'PRINT ERROR 
        '.RETURN 1
  RETURN 0     
  
END 
PUBLIC FUNCTION fS_oPTIONS(sType AS String) AS String
  
    DIM sMntOpts AS String
    
    SELECT CASE LCase(sType)
      CASE "reiserfs"
        sMntOpts = "noatime"
      CASE "vfat"
        sMntOpts = "fmask=111,dmask=0,gid=users,shortname=mixed,quiet,user"
      CASE "ntfs"
        sMntOpts = "umask=0,gid=users,user"
      CASE "ext2", "ext3"
        sMntOpts = "defaults"
      CASE ELSE 
        sMntOpts = "defaults"
    END SELECT 
    
    RETURN sMntOpts
  
  
END


PUBLIC SUB PERFORM_FULL_INSTALL() AS Integer
  
  'Will need to read SETUP.CONF to determine what to do here
  
  DIM sFile AS String[]
  DIM sEntry AS String[]
  DIM sPak AS String
  DIM sPakPath AS String
  DIM sPakSize AS Variant
  DIM sTargetSize AS Variant
  DIM iTotalSize AS Integer
  DIM iCurrSize AS Variant
  DIM sPakDesc AS String
  DIM i AS Integer
  DIM ii AS Integer
  DIM sLine AS String
  DIM sBulkPath AS String
  DIM sConfPath AS String
  DIM sOptPkgPath AS String
  DIM iVal AS Float
  DIM sBasePath AS String = ClsGlobal.sSourceMnt &/ "veclinux"
  ClsGlobal.sTargetMnt = "/home/moises/mnt/target"
    sFile = Split(File.Load(Temp$("SETUP.CONF")), "\n")
      FOR i = 0 TO sFile.count - 1
        sLine = Trim(sFile[i])
          IF Left(sLine, Len("BULK") + 1) LIKE "BULK" & "*[0-9]*" THEN 
            'sLine = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
            'sLine = Left(sLine, Len(sLine) - 1)
              sPak = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
              sPak = Left(sPak, Len(sPak) - 1)
              sEntry = Split(sPak, ":")
                sPakPath = sEntry[0]
                sPakSize = sEntry[1]
                sPakDesc = sEntry[2]
            'PRINT sBasePath &/ sPakPath & " = " & sPakDesc & " size= " & CStr(sPakSize)    
                      ' figure out the sizing and the progrss meter
                      iTotalSize = 0
                      sTargetSize = 0
                      
                        SHELL "export gsize=$(df| grep /dev/hda3) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
                          'Message(CStr(sTargetSize))
                          iTotalSize = CInt(sTargetSize) + CInt(sPakSize)
                          
                          
                        'RETURN 
                PRINT "Installing " & sPakPath & " Total size (KB) = " & CStr(sPakSize)
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sPakDesc & " ... "
              hproc = SHELL "lzmadec <" & sBasePath &/ sPakPath & " | tar -xp -C " & ClsGlobal.sTargetMnt
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 3
                          ' get the actual size at each snap
                            SHELL "export tsize=$(df | grep /dev/hda3) && echo $tsize | cut -f3 -d \' \'" TO iCurrSize
                            iCurrSize = Trim(CStr(iCurrSize))
                            'iVal = Round(CInt(iCurrSize) / CInt(iTotalSize), -2) 'CInt(iTotalSize) / CInt(iCurrSize)
                            iVal = Round((iTotalSize - iCurrSize) / iTotalSize, -2)
                            'FrmInstallSys.pbInstallProg.Value = (CInt(iCurrSize) / CInt(iTotalSize)) * 0.100
                            'PRINT CStr(iCurrSize) & "/" & CStr(iTotalSize) & " = " & iVal & "%"
                            PRINT CStr(iTotalSize) & "/" & CStr(iCurrSize) & " = " & iVal 
                            FrmInstallSys.pbInstallProg.Value = iVal
                    
                    UNTIL 
                      hproc.State = Process.Stopped
                  END IF
                PRINT sPakDesc & " is installed... "
           'PRINT "Needs to install " & sPak
          END IF
    NEXT 
  
  
END






PUBLIC FUNCTION INSTALL_BULK_PACKAGES() AS Integer
  DIM sPkg AS String
  DIM sShell AS String
  DIM hBulkInst AS Process
  DIM sExt AS String
  DIM sCMD AS String
  
  ClsGlobal.sTargetMnt = "/home/moises/mnt/target"
  
  PRINT "Installing bulk packages ... "
  FOR EACH sPkg IN RDir(ClsGlobal.sSourceMnt &/ "veclinux" &/ "required")
      sExt = Trim(File.Ext(ClsGlobal.sSourceMnt &/ "veclinux" &/ "required" &/ sPkg))
        SELECT CASE sExt
          CASE "tlz", "lzm", "lzma"
            sCMD = "lzmadec <" & ClsGlobal.sSourceMnt &/ "veclinux" &/ "required" &/ sPkg & " | tar -xp -C " & ClsGlobal.sTargetMnt
        END SELECT 
        PRINT "Installing " & sPkg
          hBulkInst = SHELL sCMD WAIT 
            
  NEXT 
  
  
  
END



PUBLIC FUNCTION INSTALL_PACKAGES() AS Integer
  
  
  
END

PUBLIC FUNCTION INSTALL_TO_HOST(sCmnd AS String) AS Integer

  hproc = SHELL sCmnd FOR READ 
  
  
END

PUBLIC SUB Process_read()
  
  DIM sLine AS String
  READ #LAST, sLine, -256
  sDump = sDump & gb.NewLine & sLine
  PRINT sLine
  
  
END

PUBLIC SUB process_error(msg AS String)

  sErr = sErr & gb.NewLine & sErr
  PRINT MSG
END 
