' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 PRIVATE hproc AS Process
 PRIVATE sDump AS String
 PRIVATE sErr AS String
 

PUBLIC FUNCTION MOUNT_DEFINED_PARTITIONS() AS Integer

 
  ' this is where we need to set the mount target
  'ClsGlobal.sTargetMnt = "/mnt/target"
  ClsGlobal.sTargetMnt = "/home/moises/mnt/target" ' just for testing now.
    IF Exist(ClsGlobal.sTargetMnt) = FALSE THEN 
      TRY MKDIR ClsGlobal.sTargetMnt
    END IF
    
    FrmInstallSys.tlCurrPkg.Text = "Mounting target partitions"
    
    SHELL "umount " & ClsGlobal.sTargetMnt WAIT 'clear the mount point
    
    '/DISABLED FOR TESTING INSTALL ONLY
    ' ' ' ' SHELL "mount " & ClsPartSel.sRoot & Space(1) & ClsGlobal.sTargetMnt & Space(1) & " -t " & ClsPartSel.fRoot WAIT  'moun the root partition first
    ' ' ' ' IF ClsPartSel.sHome THEN 
    ' ' ' '     SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "home" WAIT 
    ' ' ' '   SHELL "mount " & ClsPartSel.sHome & Space(1) & ClsGlobal.sTargetMnt &/ "home -t " & ClsPartSel.fhome WAIT 'mount the home partition if defined
      
    ' ' ' '     END IF
    IF ClsPartSel.sUsr THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "usr" WAIT 
      SHELL "mount " & ClsPartSel.sUsr & Space(1) & ClsGlobal.sTargetMnt &/ "usr -t" & ClsPartSel.fUsr WAIT ' mount the user partition
    END IF
    IF ClsPartSel.sOpt THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "opt" WAIT 
      SHELL "mount " & ClsPartSel.sOpt & Space(1) & ClsGlobal.sTargetMnt &/ "opt -t " & ClsPartSel.fOpt WAIT 'mount the opt partitiong
    END IF
    IF ClsPartSel.sVar THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "var" WAIT 
      SHELL "mount " & ClsPartSel.sVar & Space(1) & ClsGlobal.sTargetMnt &/ "var -t " & ClsPartSel.fVar WAIT 
    END IF
    IF ClsPartSel.sTmp THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "tmp" WAIT 
      SHELL "mount " & ClsPartSel.sTmp & Space(1) & ClsGlobal.sTargetMnt &/ "tmp -t " & ClsPartSel.fTmp WAIT 
    END IF
      
    ' see if there is a swap partition and use it
      IF ClsPartSel.sSwap THEN 
        SHELL "swapon -a " WAIT 
      END IF
    
    'WRITE THE NEW FSTAB NOW, RIGHT BEFORE INSTALLING PACKAGES.
    
    ME.WRITE_NEW_FSTAB() ' do this from the install form
    
    
  
  
END



PUBLIC FUNCTION WRITE_NEW_FSTAB() AS Integer
  
  DIM sEntry AS String
  DIM sPartition AS String
  DIM sMountPoint AS String
  DIM sMntOpts AS String
  DIM i AS Integer
  DIM sWinPart AS String
  DIM sWinMntPnt AS String
  DIM sFstab AS String
  
  FrmInstallSys.tlCurrPkg.Text = "Writing new /etc/fstab to system"
  
  sFstab = "# /etc/fstab: static file system information.\n" &
  "#\n" &
"#The following is an example.Please see fstab(5) for further details.\n" &
"#Please refer to mount(1) for a complete description OF mount options.\n" &
"#\n" &
"#Format:\n" &
"# < file system > < mount point > < type > < options > < dump > < pass >\n" &
"#\n" &
"#dump(8)uses the < dump > field to determine which file systems need \n" &
"# to be dumped.fsck(8)uses the < pass > column TO determine which file \n" &
"#systems need TO be checked - - the root file system should have a 1 in \n" &
"#this field, other file systems a 2, AND any file systems that should \n" &
"#not be checked(such AS MS - initrd / mnt OR NFS file systems)a 0.\n\n\n" &
"#The Linux partitions\n"

sFstab = sFstab & gb.NewLine & 
ClsPartSel.sRoot & " / " & LCase(ClsPartSel.fRoot) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fRoot)) & " 0 1" & gb.NewLine
IF ClsPartSel.sHome THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sHome & " /home " & LCase(ClsPartSel.fhome) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fhome)) & " 0 2"
END IF
IF ClsPartSel.sUsr THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sUsr & " /usr " & LCase(ClsPartSel.fUsr) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fUsr)) & " 0 2 "
END IF
IF ClsPartSel.sOpt THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sopt & " /opt " & LCase(ClsPartSel.fOpt) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fOpt)) & " 0 2 "
END IF
IF ClsPartSel.sVar THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sVar & " /var " & LCase(ClsPartSel.fVar) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fVar)) & " 0 2 "
END IF
IF ClsPartSel.sTmp THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sTmp & " /tmp " & LCase(ClsPartSel.fTmp) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fTmp)) & " 0 2 "
END IF

sFstab = sFstab & "\n\n" &
"# Shared Windows/Linux partition" &
"#/dev/hda1   /mnt/dos  msdos  umask=0   0  0 \n" &
"#/dev/hda1   /mnt/win  vfat   fmask=111,dmask=0,quiet,shortname=mixed,user  0  0 \n" &
"#/dev/hda1   /mnt/win  ntfs   umask=0   0  0\n" 
    IF ClsWinDrives.sWinDrives THEN 
      FOR i = 0 TO ClsWinDrives.sWinDrives.Count - 1
        sWinPart = Trim(Left(ClsWinDrives.sWinDrives[i], InStr(ClsWinDrives.sWinDrives[i], "|") - 1))
        sWinMntPnt = Trim(Right(ClsWinDrives.sWinDrives[i], Len(ClsWinDrives.sWinDrives[i]) - InStr(ClsWinDrives.sWinDrives[i], "|")))
        'Message("Mount " & sWinPart & " to " & sWinMntPnt)
        ' if this is right... then add it to the file
      NEXT 
    END IF

sFstab = sFstab & "\n\n" &
"# Floppy disks \n" &
"# The 'noauto' option indicates that the file system should not be mounted \n" &
"# with 'mount -a' 'user' indicates that normal users are allowed to mount \n" &
"# the file system. \n" &
"/dev/fd0   /mnt/floppy  auto  defaults,noauto,user  0 0 \n" &
"#/dev/fd1  /mnt/floppy  auto  defaults,noauto,user  0 0 \n\n" &
"# If you have a ls-120 floppy drive, it could be on /dev/hda b c d etc.\n" &
"#/dev/hdd  /mnt/ls120  auto  defaults,noauto,user  0 0 \n\n" &
"# CDROM, CDWRITER, DVD \n" &
"/dev/cdrom    /media/cdrom  iso9660  defaults,noauto,ro,user  0 0 \n" &
"#/dev/cdwriter /media/cdwriter  iso9660  defaults,noauto,rw,user  0 0 \n" &
"#/dev/dvd      /media/dvd   auto  defaults,noauto,ro,user  0 0\n\n" &
"# NFS file systems:\n" &
"#linux01.gwdg.de:/suse/6.3/i386.de  /mnt/nfs  nfs  defaults  0 0\n\n" &
"# proc file system:\n" &
"proc  /proc  proc  defaults  0 0\n\n" &
"# Unix98 devpts filesystem: \n" &
"none  /dev/pts  devpts  gid=5,mode=666  0 0\n\n" &
"# Shared memory filesystem: \n" &
"tmpfs   /dev/shm    tmpfs defaults 0  0 \n\n" &
"# Basic USB filesystem\n" &
"sysfs  /sys  sysfs  defaults  0 0\n" &
"usbfs /proc/bus/usb usbfs rw,devmode=0666 0 0\n\n" &
"# example of a VFAT USB pendrive\n" &
"#/dev/sda1  /mnt/pendrive vfat   fmask=111,dmask=0,noauto,user,quiet,shortname=mixed 0 0\n\n" &
"# Swap partitions\n" &
"# The 'sw' option means auto activating with 'swapon -a'.\n"
IF ClsPartSel.sSwap THEN 
  sFstab = sFstab & gb.NewLine &
   ClsPartSel.sSwap & Space(5) & "none" & Space(5) & "swap" & Space(5) & "sw" & Space(5) & "0" & Space(5) & "0"
END IF

sFstab = sFstab & "\n"
' Wheewww!... that's the whole fstab there... Please fix the win partitions
 
 'Message(sFstab)
 
 IF NOT ClsGlobal.sTargetMnt OR ClsGlobal.sTargetMnt = "" THEN 
  ClsGlobal.sTargetMnt = "/home/moises/mnt/target"
 END IF
 
 ';Message(ClsGlobal.sTargetMnt &/ "etc")
  ' now save the file to /etc/fstab
      IF Exist(ClsGlobal.sTargetMnt &/ "etc") = FALSE THEN 
        MKDIR ClsGlobal.sTargetMnt &/ "etc"
      END IF
    TRY File.Save(ClsGlobal.sTargetMnt &/ "etc" &/ "fstab", SConv(sFstab))
      CATCH 
      PRINT ERROR 
        '.RETURN 1
        
  
END 
PUBLIC FUNCTION fS_oPTIONS(sType AS String) AS String
  
    DIM sMntOpts AS String
    
    SELECT CASE LCase(sType)
      CASE "reiserfs"
        sMntOpts = "noatime"
      CASE "vfat"
        sMntOpts = "fmask=111,dmask=0,gid=users,shortname=mixed,quiet,user"
      CASE "ntfs"
        sMntOpts = "umask=0,gid=users,user"
      CASE "ext2", "ext3"
        sMntOpts = "defaults"
      CASE ELSE 
        sMntOpts = "defaults"
    END SELECT 
    
    RETURN sMntOpts
  
  
END

PUBLIC FUNCTION INSTALL_BULK_PACKAGES() AS Integer
  DIM i AS Integer
  DIM sShell AS String
  DIM sPKG AS String
  DIM sDump AS String
  DIM sBulkList AS String
  DIM sType AS String
  DIM sList AS String[]
  DIM sBulk AS String
  DIM sBulkPath AS String = ClsGlobal.sSourceMnt &/ "veclinux" &/ "required"
    
    SHELL "ls -m " & sBulkPath TO sBulkList
      sList = Split(sBulkList, ",")
        FOR i = 0 TO sList.Count - 1
          sBulk = Trim(sList[i])
            sType = File.Ext(sBulkPath &/ sBulk)
                ' SELECT CASE sType
                '   CASE "tlz", "lzm", "lzma"
                    sShell = "lzmadec " & sBulkPath &/ sBulk & " | tar -xp -C " & ClsGlobal.sTargetMnt
                    'Message(sBulkPath &/ sBulk & " | tar -xp -C " & ClsGlobal.sTargetMnt)
'                 END SELECT 
            'Message(sShell)
            'Message(ClsGlobal.sSourceMnt &/ "veclinux" &/ "required" &/ sBulk)
            
            'Message("type = " & sType & " command = " & sShell)
            hproc = SHELL sShell FOR READ 
              WAIT 
                IF hproc.State = Process.Running THEN 
                  REPEAT 
                    WAIT 
                      PRINT "Installing " & sBulk
                  UNTIL 
                  hproc.State = Process.Stopped
                END IF
        NEXT 
                
    
  ' ' '     
  ' ' ' 
  ' ' '   IF ClsPkgSel.bCustom = TRUE THEN 
  ' ' '     ' need to get the list of packages selected by user
  ' ' '   ELSE 
  ' ' '     ' do the optional bulks first
  ' ' '           
  ' ' '       'FOR EACH sPKG IN RDir(ClsGlobal.sSourceMnt &/ "veclinux" &/ "optional")
  ' ' '           SELECT CASE File.Ext(sPkg)
  ' ' '             CASE "tlz", "lzm", "lzma"
  ' ' '               sShell = "lzmadec < " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "optional" &/ sPkg & " | tar -xp -C " & ClsGlobal.sTargetMnt
  ' ' '                 
  ' ' '             CASE "bz2", "tbz2", "tbz"
  ' ' '               sShell = "tar -xpjf " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "optional" &/ sPkg & " -C " & ClsGlobal.sTargetMnt
  ' ' '           END SELECT 
  ' ' '           
  ' ' '           'FrmInstallSys.tlCurrPkg.Text = "Installing " & sPkg
  ' ' '           
  ' ' '           'hproc = SHELL sShell
  ' ' '           Message(sShell)
  ' ' '           RETURN 1
  ' ' '            ME.INSTALL_TO_HOST(sShell)
  ' ' '            
  ' ' '           ' '   WAIT 
  ' ' '           ' '     IF hproc.State = Process.Running THEN 
  ' ' '           ' '       REPEAT 
  ' ' '           ' '     ' IF hproc.State = Process.Running THEN 
  ' ' '           ' '         FrmInstallSys.pbInstallProg.Value = FrmInstallSys.pbInstallProg.Value + 0.00001
  ' ' '           ' '           WAIT 
  ' ' '           ' '      '   END IF
  ' ' '           ' '         UNTIL hproc.State = Process.Stopped
  ' ' '           ' '       'END IF
  ' ' '           ' '     
  ' ' '           ' '     sDump = Trim(sDump)
  ' ' '           ' '     sErr = Trim(sErr)
  ' ' '           ' '       IF serr <> "" THEN 
  ' ' '           ' '         Message("There has been an error installing " & sPkg & gb.NewLine & "<b>Error:</b>" & gb.NewLine & serr)
  ' ' '           ' '         RETURN 1
  ' ' '           ' '       END IF
  ' ' '           ' '    'Message(sPkg & " is installed")
  ' ' '           ' '         END IF
  ' ' '       NEXT 
  ' ' '       'RETURN 
  ' ' '       
  ' ' ' END IF
  ' ' ' 
END



PUBLIC FUNCTION INSTALL_PACKAGES() AS Integer
  
  
  
END

PUBLIC FUNCTION INSTALL_TO_HOST(sCmnd AS String) AS Integer

  hproc = SHELL sCmnd FOR READ 
  
  
END

PUBLIC SUB Process_read()
  
  DIM sLine AS String
  READ #LAST, sLine, -256
  sDump = sDump & gb.NewLine & sLine
  PRINT sLine
  
  
END

PUBLIC SUB process_error(msg AS String)

  sErr = sErr & gb.NewLine & sErr
  PRINT MSG
END 