' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 PRIVATE hproc AS Process
 PRIVATE sDump AS String
 PRIVATE sErr AS String

PRIVATE iPkgCnt AS Integer
PRIVATE iPkgNum AS Integer = 0
  
 

PUBLIC FUNCTION MOUNT_DEFINED_PARTITIONS() AS Integer

 
  ' this is where we need to set the mount target
  'ClsGlobal.sTargetMnt = "/mnt/target"
  ClsGlobal.sTargetMnt = "/mnt/target" ' just for testing now.
    IF Exist(ClsGlobal.sTargetMnt) = FALSE THEN 
      TRY MKDIR ClsGlobal.sTargetMnt
    END IF
    
  '  FrmInstallSys.tlCurrPkg.Text = "Mounting target partitions"
    
    SHELL "umount " & ClsGlobal.sTargetMnt WAIT 'clear the mount point
    
    '/DISABLED FOR TESTING INSTALL ONLY
    SHELL "mount " & ClsPartSel.sRoot & Space(1) & ClsGlobal.sTargetMnt WAIT  'moun the root partition first
    IF ClsPartSel.sHome THEN 
       SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "home" WAIT 
       SHELL "mount " & ClsPartSel.sHome & Space(1) & ClsGlobal.sTargetMnt &/ "home -t " & ClsPartSel.fhome WAIT 'mount the home partition if defined
      
    END IF
    IF ClsPartSel.sUsr THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "usr" WAIT 
      SHELL "mount " & ClsPartSel.sUsr & Space(1) & ClsGlobal.sTargetMnt &/ "usr -t" & ClsPartSel.fUsr WAIT ' mount the user partition
    END IF
    IF ClsPartSel.sOpt THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "opt" WAIT 
      SHELL "mount " & ClsPartSel.sOpt & Space(1) & ClsGlobal.sTargetMnt &/ "opt -t " & ClsPartSel.fOpt WAIT 'mount the opt partitiong
    END IF
    IF ClsPartSel.sVar THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "var" WAIT 
      SHELL "mount " & ClsPartSel.sVar & Space(1) & ClsGlobal.sTargetMnt &/ "var -t " & ClsPartSel.fVar WAIT 
    END IF
    IF ClsPartSel.sTmp THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "tmp" WAIT 
      SHELL "mount " & ClsPartSel.sTmp & Space(1) & ClsGlobal.sTargetMnt &/ "tmp -t " & ClsPartSel.fTmp WAIT 
    END IF
      
    ' see if there is a swap partition and use it
      IF ClsPartSel.sSwap THEN 
        SHELL "swapon -a " WAIT 
      END IF
    
    'WRITE THE NEW FSTAB NOW, RIGHT BEFORE INSTALLING PACKAGES.
    
    ME.WRITE_NEW_FSTAB() ' do this from the install form
      'redirect to packages install
      'ME.INSTALL_PACKAGES()
    
    
  
  
END



PUBLIC FUNCTION WRITE_NEW_FSTAB() AS Integer
  
  DIM sEntry AS String
  DIM sPartition AS String
  DIM sMountPoint AS String
  DIM sMntOpts AS String
  DIM i AS Integer
  DIM sWinPart AS String
  DIM sWinMntPnt AS String
  DIM sFstab AS String
  
  FrmInstallSys.tlCurrPkg.Text = "Writing new /etc/fstab to system"
  
  sFstab = "# /etc/fstab: static file system information.\n" &
  "#\n" &
"#The following is an example.Please see fstab(5) for further details.\n" &
"#Please refer to mount(1) for a complete description OF mount options.\n" &
"#\n" &
"#Format:\n" &
"# < file system > < mount point > < type > < options > < dump > < pass >\n" &
"#\n" &
"#dump(8)uses the < dump > field to determine which file systems need \n" &
"# to be dumped.fsck(8)uses the < pass > column TO determine which file \n" &
"#systems need TO be checked - - the root file system should have a 1 in \n" &
"#this field, other file systems a 2, AND any file systems that should \n" &
"#not be checked(such AS MS - initrd / mnt OR NFS file systems)a 0.\n\n\n" &
"#The Linux partitions\n"

sFstab = sFstab & gb.NewLine & 
ClsPartSel.sRoot & " / " & LCase(ClsPartSel.fRoot) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fRoot)) & " 0 1" & gb.NewLine
IF ClsPartSel.sHome THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sHome & " /home " & LCase(ClsPartSel.fhome) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fhome)) & " 0 2"
END IF
IF ClsPartSel.sUsr THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sUsr & " /usr " & LCase(ClsPartSel.fUsr) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fUsr)) & " 0 2 "
END IF
IF ClsPartSel.sOpt THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sopt & " /opt " & LCase(ClsPartSel.fOpt) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fOpt)) & " 0 2 "
END IF
IF ClsPartSel.sVar THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sVar & " /var " & LCase(ClsPartSel.fVar) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fVar)) & " 0 2 "
END IF
IF ClsPartSel.sTmp THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sTmp & " /tmp " & LCase(ClsPartSel.fTmp) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fTmp)) & " 0 2 "
END IF

sFstab = sFstab & "\n\n" &
"# Shared Windows/Linux partition" &
"#/dev/hda1   /mnt/dos  msdos  umask=0   0  0 \n" &
"#/dev/hda1   /mnt/win  vfat   fmask=111,dmask=0,quiet,shortname=mixed,user  0  0 \n" &
"#/dev/hda1   /mnt/win  ntfs   umask=0   0  0\n" 
    IF ClsWinDrives.sWinDrives THEN 
      FOR i = 0 TO ClsWinDrives.sWinDrives.Count - 1
        sWinPart = Trim(Left(ClsWinDrives.sWinDrives[i], InStr(ClsWinDrives.sWinDrives[i], "|") - 1))
        sWinMntPnt = Trim(Right(ClsWinDrives.sWinDrives[i], Len(ClsWinDrives.sWinDrives[i]) - InStr(ClsWinDrives.sWinDrives[i], "|")))
        'Message("Mount " & sWinPart & " to " & sWinMntPnt)
        ' if this is right... then add it to the file
      NEXT 
    END IF

sFstab = sFstab & "\n\n" &
"# Floppy disks \n" &
"# The 'noauto' option indicates that the file system should not be mounted \n" &
"# with 'mount -a' 'user' indicates that normal users are allowed to mount \n" &
"# the file system. \n" &
"/dev/fd0   /mnt/floppy  auto  defaults,noauto,user  0 0 \n" &
"#/dev/fd1  /mnt/floppy  auto  defaults,noauto,user  0 0 \n\n" &
"# If you have a ls-120 floppy drive, it could be on /dev/hda b c d etc.\n" &
"#/dev/hdd  /mnt/ls120  auto  defaults,noauto,user  0 0 \n\n" &
"# CDROM, CDWRITER, DVD \n" &
"/dev/cdrom    /media/cdrom  iso9660  defaults,noauto,ro,user  0 0 \n" &
"#/dev/cdwriter /media/cdwriter  iso9660  defaults,noauto,rw,user  0 0 \n" &
"#/dev/dvd      /media/dvd   auto  defaults,noauto,ro,user  0 0\n\n" &
"# NFS file systems:\n" &
"#linux01.gwdg.de:/suse/6.3/i386.de  /mnt/nfs  nfs  defaults  0 0\n\n" &
"# proc file system:\n" &
"proc  /proc  proc  defaults  0 0\n\n" &
"# Unix98 devpts filesystem: \n" &
"none  /dev/pts  devpts  gid=5,mode=666  0 0\n\n" &
"# Shared memory filesystem: \n" &
"tmpfs   /dev/shm    tmpfs defaults 0  0 \n\n" &
"# Basic USB filesystem\n" &
"sysfs  /sys  sysfs  defaults  0 0\n" &
"usbfs /proc/bus/usb usbfs rw,devmode=0666 0 0\n\n" &
"# example of a VFAT USB pendrive\n" &
"#/dev/sda1  /mnt/pendrive vfat   fmask=111,dmask=0,noauto,user,quiet,shortname=mixed 0 0\n\n" &
"# Swap partitions\n" &
"# The 'sw' option means auto activating with 'swapon -a'.\n"
IF ClsPartSel.sSwap THEN 
  sFstab = sFstab & gb.NewLine &
   ClsPartSel.sSwap & Space(5) & "none" & Space(5) & "swap" & Space(5) & "sw" & Space(5) & "0" & Space(5) & "0"
END IF

sFstab = sFstab & "\n"
' Wheewww!... that's the whole fstab there... Please fix the win partitions
 
 'Message(sFstab)
 
 IF NOT ClsGlobal.sTargetMnt OR ClsGlobal.sTargetMnt = "" THEN 
  ClsGlobal.sTargetMnt = "/mnt/target"
 END IF
 
 ';Message(ClsGlobal.sTargetMnt &/ "etc")
  ' now save the file to /etc/fstab
      IF Exist(ClsGlobal.sTargetMnt &/ "etc") = FALSE THEN 
        MKDIR ClsGlobal.sTargetMnt &/ "etc"
      END IF
    File.Save(ClsGlobal.sTargetMnt &/ "etc" &/ "fstab", SConv(sFstab))
      'CATCH 
      'PRINT ERROR 
        '.RETURN 1
  'RETURN 0     
    IF ClsPkgSel.bCustom = TRUE THEN 
      ' perform custom install
    ELSE 
        FrmInstallSys.tlCurrPkg.Text = "Vectorlinux is now installing ... Please wait"
      ME.PERFORM_FULL_INSTALL()
        're-direct to packages for now
        FrmInstallSys.tlCurrPkg.Text = "Installing Additional software... Please wait"
      ME.INSTALL_REQUIRED_PACKAGES()
      ME.INSTALL_PACKAGES()
    END IF
  
END 
PUBLIC FUNCTION fS_oPTIONS(sType AS String) AS String
  
    DIM sMntOpts AS String
    
    SELECT CASE LCase(sType)
      CASE "reiserfs"
        sMntOpts = "noatime"
      CASE "vfat"
        sMntOpts = "fmask=111,dmask=0,gid=users,shortname=mixed,quiet,user"
      CASE "ntfs"
        sMntOpts = "umask=0,gid=users,user"
      CASE "ext2", "ext3"
        sMntOpts = "defaults"
      CASE ELSE 
        sMntOpts = "defaults"
    END SELECT 
    
    RETURN sMntOpts
  
  
END


PUBLIC SUB PERFORM_FULL_INSTALL() AS Integer
  
  'Will need to read SETUP.CONF to determine what to do here
  
  DIM sFile AS String[]
  DIM sEntry AS String[]
  DIM stlzList AS String[]
  DIM sTlz AS String
  DIM sPak AS String
  DIM sPakPath AS String
  DIM sPakSize AS Variant
  DIM sTargetSize AS Variant
  DIM iTotalSize AS Integer
  DIM iCurrSize AS Variant
  DIM sPakDesc AS String
  DIM i AS Integer
  DIM ii AS Integer
  DIM sLine AS String
  DIM sBulkPath AS String
  DIM sConfPath AS String
  DIM sOptPkgPath AS String
  DIM iVal AS Float
  
  DIM sBasePath AS String = ClsGlobal.sSourceMnt &/ "veclinux"
      
      WITH FrmInstallSys
        .Resize(FMain.pnlWinHost.Width, FMain.pnlWinHost.Height)
      END WITH 
  iPkgCnt = MdlSetup.CALCULATE_PACKAGE_COUNT(FALSE)
    Message.Info("Total packages = " & iPkgCnt)
  RETURN 
  ' make sure the progress is revealed at the main window
    WITH FMain
    .tvPlan["Inst1"].Picture = MdlCore.sDonePic
    .tvPlan["Inst2"].Selected = TRUE
    .tvPlan["Inst2"].Picture = MdlCore.sNowPic
    END WITH 
  
  
  MdlSetup.SHOW_PROGRESS_CONTROLS()
  FrmInstallSys.tlBanner.Text = "Vectorlinux is now being installed. Please wait..."
  ClsGlobal.sTargetMnt = "/mnt/target"
    sFile = Split(File.Load(Temp$("SETUP.CONF")), "\n")
      FOR i = 0 TO sFile.count - 1
        sLine = Trim(sFile[i])

          IF Left(sLine, Len("BULK") + 1) LIKE "BULK" & "*[0-9]*" THEN 
            sLine = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
            sLine = Left(sLine, Len(sLine) - 1)
              sPak = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
              sPak = Left(sPak, Len(sPak) - 1)
              sEntry = Split(sPak, ":")
                sPakPath = sEntry[0]
                sPakSize = sEntry[1]
                sPakDesc = sEntry[2]
                  'PRINT sBasePath &/ sPakPath & " = " & sPakDesc & " size= " & CStr(sPakSize)    
                      ' figure out the sizing and the progrss meter
                        SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
                          'Message(CStr(sTargetSize))
                          sTargetSize = Trim(CStr(sTargetSize))
                          sPakSize = Trim(CStr(sPakSize))
'                 
                          
                        'RETURN 
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sPakDesc & " ..."
                FrmInstallSys.pbInstallProg.Value = 0.0
                
                PRINT "Installing " & sPakDesc & " Total size (KB) = " & CStr(sPakSize)
                sDump = ""
                sErr = ""
                  MdlCore.LOCK_GUI()
              hproc = SHELL "lzmadec <" & sBasePath &/ sPakPath & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
              
                WAIT 2
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 2
                           UPDATE_STEP_PROGRESS(sTargetSize, sPakSize)
                                      
                            
                    UNTIL 
                      hproc.State = Process.Stopped
                          ' error check
                            IF InStr(sDump, "FAILED") > 0 THEN 
                              Message.Error("There has been an error extracting " & sPakDesc & gb.NewLine &
                              "<b>ERROR</b>" & gb.NewLine &
                              sErr)
                              RETURN 1
                            ELSE 
                              FrmInstallSys.pbInstallProg.Value = 1
                              
                  END IF
                PRINT sPak & " is installed... "
                INC iPkgNum
                              FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
                            END IF
           'PRINT "Needs to install " & sPak
          END IF
    NEXT 
  FrmInstallSys.tlBanner.Text = "Finished intalling Bulks"
  
        ' now to the packages individually
        
  
  
END

PUBLIC SUB UPDATE_STEP_PROGRESS(sTargetSize AS Float, sPakSize AS Float)
  
  DIM iMBProgress AS Float
  DIM ipct AS Float
  DIM iMinpct AS Float = ".01"
  DIM iMaxpct AS Float = ".99"
  DIM iVal AS Float
  DIM iProgress AS Float
  DIM iCurrSize AS Variant
 
  SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO iCurrSize
  iCurrSize = Trim(CStr(iCurrSize))
  iProgress = CInt(iCurrSize - sTargetSize)
  iMBProgress = iProgress / 1024
  IF iMBProgress > CFloat(sPakSize) THEN 
    iVal = iMaxpct
  ELSE 
    ipct = 100 * iMBProgress
    iVal = ipct / sPakSize * 10
    IF iVal < iMinpct THEN 
      iVal = iMinpct
    ENDIF 
    IF iVal > iMaxpct THEN 
      iVal = iMaxpct
    ENDIF 
  ENDIF 
  IF iVal > FrmInstallSys.pbInstallProg.Value THEN 
    FrmInstallSys.pbInstallProg.Value = iVal
  END IF
  PRINT CStr(iCurrSize) & "/" & CStr(sTargetSize + sPakSize) & " = " & iVal & "%"
END




PUBLIC FUNCTION INSTALL_PACKAGES() AS Integer
  
    DIM i AS Integer
    DIM sFile AS String[]
    DIM sLine AS String
    DIM sRawFile AS String
    DIM sTlzPath AS String
    DIM sTlzName AS String
    DIM sTlzDesc AS String
    DIM iTlzSize AS Integer
    DIM sTlzBasePath AS String = ClsGlobal.sSourceMnt &/ "packages"
    DIM sTargetSize AS Variant
    
    sRawFile = DConv(File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT"))
    
      sFile = Split(sRawFile, "\n")
        FOR i = 0 TO sFile.count - 1
          sLine = Trim(sFile[i])
            IF Left(sLine, Len("PACKAGE NAME")) = "PACKAGE NAME" THEN 
              sTlzName = Trim(Right(sLine, Len(sLine) - InStr(sLine, ":")))
              sTlzPath = Trim(Right(sFile[i + 1], Len(sFile[i + 1]) - InStr(sFile[i + 1], ":")))
              sTlzPath = Right(sTlzPath, Len(sTlzPath) - 2) ' remove the ./ from the location line
              iTlzSize = Trim(Right(sFile[i + 3], Len(sFile[i + 3]) - InStr(sFile[i + 3], ":")))
              'iTlzSize = Left(iTlzSize, Len(iTlzSize) - 1)
              'iTlzSize = Trim(iTlzSize)
              FrmInstallSys.tlCurrPkg.Text = "Installing " & sTlzName & " ..."
              FrmInstallSys.pbInstallProg.Value = 0.0
              
              PRINT " Install " & sTlzBasePath &/ sTlzPath &/ sTlzName 
                  ' install each package
               SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
               sTargetSize = Trim(CStr(sTargetSize))

          
              
              sDump = ""
              sErr = ""
              hproc = SHELL "install-pkg " & sTlzBasePath &/ sTlzPath &/ sTlzName & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 1
                      UPDATE_STEP_PROGRESS(sTargetSize, iTlzSize)
                          ' figure out the progress again

                    UNTIL 
                      hproc.State = Process.Stopped
                          IF InStr(sDump, "FAILED") > 0 THEN 
                            ERROR 
                            RETURN 1
                          ELSE 
                            IF FrmInstallSys.pbInstallProg.Value <> 1 THEN 
                              FrmInstallSys.pbInstallProg.Value = 1
                            END IF
                          END IF
                  END IF
                                            INC iPkgNum
                              FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
          END IF
      NEXT 
            
    ' DONE INSTALLING SOFTWARE. 
      'Message.Info("Installation complete. Ready for configuration"
      FrmInstallSys.tlBanner.Text = "Installation phase complete. Ready for configuration"
      FrmInstallSys.pbInstallProg.Value = 1
      MdlCore.unlock_gui()
    
  
END
PUBLIC FUNCTION INSTALL_REQUIRED_PACKAGES() AS Integer
  
    DIM i AS Integer
    DIM sFile AS String[]
    DIM sLine AS String
    DIM sRawFile AS String
    DIM sTlzPath AS String
    DIM sTlzName AS String
    DIM sTlzDesc AS String
    DIM sTlzBasePath AS String = ClsGlobal.sSourceMnt &/ "packages"
    
    'sRawFile = DConv(File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT"))
     SHELL "ls /mnt/cdrom/packages/required/*.t?z" TO sRawFile
      sFile = Split(sRawFile, "\n")
        'SHELL "ls /mnt/cdrom/packages/required/*.t?z" TO sFile
        FOR i = 0 TO sFile.count - 1
          sLine = Trim(sFile[i])
            'IF Left(sLine, Len("PACKAGE NAME")) = "PACKAGE NAME" THEN 
              sTlzName = Trim(Right(sLine, Len(sLine) - InStr(sLine, "/")))
              sTlzPath = Trim(Right(sFile[i + 1], Len(sFile[i + 1]) - InStr(sFile[i + 1], "/")))
              'sTlzPath = Right(sTlzPath, Len(sTlzPath) - 2) ' remove the ./ from the location line
            'END IF
          ' now install the package with the information we already have
          PRINT sTlzName & sTlzPath
              sDump = ""
              sErr = ""
              FrmInstallSys.tlCurrPkg.Text = "Installing " & sTlzName & " ..."
              FrmInstallSys.pbInstallProg.Value = 0.0
              hproc = SHELL "install-pkg " & sTlzName & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 2
                          ' figure out the progress again
                    UNTIL 
                      hproc.State = Process.Stopped
                  END IF
      NEXT 
            
    
    
  
END


PUBLIC SUB Process_read()
  
  DIM sLine AS String
  READ #LAST, sLine, -256
  sDump = sDump & gb.NewLine & sLine
  PRINT sLine
  
  
END

PUBLIC SUB process_error(msg AS String)

  sErr = sErr & gb.NewLine & sErr
  PRINT MSG
END 
