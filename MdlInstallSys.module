' Gambas module file

'    This file is part of vinstall-ng

'    vinstall-ng is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 2 of the License, or
'    (at your option) any later version.

'    vinstall-ng  is distributed in the hope that it will be useful,
'    but WITHOUT ANY WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

'    You should have received a copy of the GNU General Public License
'    along with vinstall-ng.  If not, see <http://www.gnu.org/licenses/>.

 PRIVATE hproc AS Process
 PRIVATE sDump AS String
 PRIVATE sErr AS String
 PRIVATE iPkgCnt AS Integer
 PRIVATE iPkgNum AS Integer = 0
  
 

PUBLIC FUNCTION MOUNT_DEFINED_PARTITIONS() AS Integer

 
  ' this is where we need to set the mount target
  ClsGlobal.sTargetMnt = "/mnt/target"
    IF Exist(ClsGlobal.sTargetMnt) = FALSE THEN 
      TRY MKDIR ClsGlobal.sTargetMnt
    END IF   
    SHELL "umount " & ClsGlobal.sTargetMnt WAIT 'clear the mount point
    
    '/DISABLED FOR TESTING INSTALL ONLY
    SHELL "mount " & ClsPartSel.sRoot & Space(1) & ClsGlobal.sTargetMnt WAIT  'moun the root partition first
    IF ClsPartSel.sHome THEN 
       SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "home" WAIT 
       SHELL "mount " & ClsPartSel.sHome & Space(1) & ClsGlobal.sTargetMnt &/ "home -t " & LCase(ClsPartSel.fhome) WAIT 'mount the home partition if defined
      
    END IF
    IF ClsPartSel.sUsr THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "usr" WAIT 
      SHELL "mount " & ClsPartSel.sUsr & Space(1) & ClsGlobal.sTargetMnt &/ "usr -t" & ClsPartSel.fUsr WAIT ' mount the user partition
    END IF
    IF ClsPartSel.sOpt THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "opt" WAIT 
      SHELL "mount " & ClsPartSel.sOpt & Space(1) & ClsGlobal.sTargetMnt &/ "opt -t " & ClsPartSel.fOpt WAIT 'mount the opt partitiong
    END IF
    IF ClsPartSel.sVar THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "var" WAIT 
      SHELL "mount " & ClsPartSel.sVar & Space(1) & ClsGlobal.sTargetMnt &/ "var -t " & ClsPartSel.fVar WAIT 
    END IF
    IF ClsPartSel.sTmp THEN 
      SHELL "mkdir -p " & ClsGlobal.sTargetMnt &/ "tmp" WAIT 
      SHELL "mount " & ClsPartSel.sTmp & Space(1) & ClsGlobal.sTargetMnt &/ "tmp -t " & ClsPartSel.fTmp WAIT 
    END IF
      
    ' see if there is a swap partition and use it
      IF ClsPartSel.sSwap THEN 
        SHELL "swapon -a " WAIT 
      END IF
    
    'WRITE THE NEW FSTAB NOW, RIGHT BEFORE INSTALLING PACKAGES.
    
    'ME.WRITE_NEW_FSTAB() ' do this from the install form
      'redirect to packages install
      'ME.INSTALL_PACKAGES()
    ' FROM HERE, DECIDE WHICH WAY TO GO
      IF ClsPkgSel.bCustom = TRUE THEN 
        MdlInstallCustom.PERFORM_CUSTOM_INSTALL
      ELSE 
        MdlInstallSys.PERFORM_FULL_INSTALL()
      END IF  
END


PUBLIC FUNCTION WRITE_NEW_FSTAB() AS Integer
  
  DIM sEntry AS String
  DIM sPartition AS String
  DIM sMountPoint AS String
  DIM sMntOpts AS String
  DIM i AS Integer
  DIM sWinPart AS String
  DIM sWinMntPnt AS String
  DIM sFstab AS String
  
  ' make the changes show up on the steps now  
  FrmInstallSys.tlCurrPkg.Text = "Writing new /etc/fstab to system"
  
  sFstab = "# /etc/fstab: static file system information.\n" &
  "#\n" &
"#The following is an example.Please see fstab(5) for further details.\n" &
"#Please refer to mount(1) for a complete description OF mount options.\n" &
"#\n" &
"#Format:\n" &
"# < file system > < mount point > < type > < options > < dump > < pass >\n" &
"#\n" &
"#dump(8)uses the < dump > field to determine which file systems need \n" &
"# to be dumped.fsck(8)uses the < pass > column TO determine which file \n" &
"#systems need TO be checked - - the root file system should have a 1 in \n" &
"#this field, other file systems a 2, AND any file systems that should \n" &
"#not be checked(such AS MS - initrd / mnt OR NFS file systems)a 0.\n\n\n" &
"#The Linux partitions\n"

sFstab = sFstab & gb.NewLine & 
ClsPartSel.sRoot & " / " & LCase(ClsPartSel.fRoot) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fRoot)) & " 0 1" & gb.NewLine
IF ClsPartSel.sHome THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sHome & " /home " & LCase(ClsPartSel.fhome) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fhome)) & " 0 2"
END IF
IF ClsPartSel.sUsr THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sUsr & " /usr " & LCase(ClsPartSel.fUsr) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fUsr)) & " 0 2 "
END IF
IF ClsPartSel.sOpt THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sopt & " /opt " & LCase(ClsPartSel.fOpt) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fOpt)) & " 0 2 "
END IF
IF ClsPartSel.sVar THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sVar & " /var " & LCase(ClsPartSel.fVar) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fVar)) & " 0 2 "
END IF
IF ClsPartSel.sTmp THEN 
  sFstab = sFstab & gb.NewLine & ClsPartSel.sTmp & " /tmp " & LCase(ClsPartSel.fTmp) & " " & ME.fS_oPTIONS(LCase(ClsPartSel.fTmp)) & " 0 2 "
END IF

sFstab = sFstab & "\n\n" &
"# Shared Windows/Linux partition" &
"#/dev/hda1   /mnt/dos  msdos  umask=0   0  0 \n" &
"#/dev/hda1   /mnt/win  vfat   fmask=111,dmask=0,quiet,shortname=mixed,user  0  0 \n" &
"#/dev/hda1   /mnt/win  ntfs   umask=0   0  0\n" 
    IF ClsWinDrives.sWinDrives THEN 
      FOR i = 0 TO ClsWinDrives.sWinDrives.Count - 1
        sWinPart = Trim(Left(ClsWinDrives.sWinDrives[i], InStr(ClsWinDrives.sWinDrives[i], "|") - 1))
        sWinMntPnt = Trim(Right(ClsWinDrives.sWinDrives[i], Len(ClsWinDrives.sWinDrives[i]) - InStr(ClsWinDrives.sWinDrives[i], "|")))
        'Message("Mount " & sWinPart & " to " & sWinMntPnt)
        ' if this is right... then add it to the file
      NEXT 
    END IF

sFstab = sFstab & "\n\n" &
"# Floppy disks \n" &
"# The 'noauto' option indicates that the file system should not be mounted \n" &
"# with 'mount -a' 'user' indicates that normal users are allowed to mount \n" &
"# the file system. \n" &
"/dev/fd0   /mnt/floppy  auto  defaults,noauto,user  0 0 \n" &
"#/dev/fd1  /mnt/floppy  auto  defaults,noauto,user  0 0 \n\n" &
"# If you have a ls-120 floppy drive, it could be on /dev/hda b c d etc.\n" &
"#/dev/hdd  /mnt/ls120  auto  defaults,noauto,user  0 0 \n\n" &
"# CDROM, CDWRITER, DVD \n" &
"/dev/cdrom    /media/cdrom  iso9660  defaults,noauto,ro,user  0 0 \n" &
"#/dev/cdwriter /media/cdwriter  iso9660  defaults,noauto,rw,user  0 0 \n" &
"#/dev/dvd      /media/dvd   auto  defaults,noauto,ro,user  0 0\n\n" &
"# NFS file systems:\n" &
"#linux01.gwdg.de:/suse/6.3/i386.de  /mnt/nfs  nfs  defaults  0 0\n\n" &
"# proc file system:\n" &
"proc  /proc  proc  defaults  0 0\n\n" &
"# Unix98 devpts filesystem: \n" &
"none  /dev/pts  devpts  gid=5,mode=666  0 0\n\n" &
"# Shared memory filesystem: \n" &
"tmpfs   /dev/shm    tmpfs defaults 0  0 \n\n" &
"# Basic USB filesystem\n" &
"sysfs  /sys  sysfs  defaults  0 0\n" &
"usbfs /proc/bus/usb usbfs rw,devmode=0666 0 0\n\n" &
"# example of a VFAT USB pendrive\n" &
"#/dev/sda1  /mnt/pendrive vfat   fmask=111,dmask=0,noauto,user,quiet,shortname=mixed 0 0\n\n" &
"# Swap partitions\n" &
"# The 'sw' option means auto activating with 'swapon -a'.\n"
IF ClsPartSel.sSwap THEN 
  sFstab = sFstab & gb.NewLine &
   ClsPartSel.sSwap & Space(5) & "none" & Space(5) & "swap" & Space(5) & "sw" & Space(5) & "0" & Space(5) & "0"
END IF

sFstab = sFstab & "\n"
' Wheewww!... that's the whole fstab there... Please fix the win partitions
 

  ' now save the file to /etc/fstab
      IF Exist(ClsGlobal.sTargetMnt &/ "etc") = FALSE THEN 
        MKDIR ClsGlobal.sTargetMnt &/ "etc"
      END IF
    File.Save(ClsGlobal.sTargetMnt &/ "etc" &/ "fstab", SConv(sFstab))
 
END 


PUBLIC FUNCTION fS_oPTIONS(sType AS String) AS String
  
    DIM sMntOpts AS String
    
    SELECT CASE LCase(sType)
      CASE "reiserfs"
        sMntOpts = "noatime"
      CASE "vfat"
        sMntOpts = "fmask=111,dmask=0,gid=users,shortname=mixed,quiet,user"
      CASE "ntfs"
        sMntOpts = "umask=0,gid=users,user"
      CASE "ext2", "ext3"
        sMntOpts = "defaults"
      CASE ELSE 
        sMntOpts = "defaults"
    END SELECT 
    
    RETURN sMntOpts  
END


PUBLIC SUB PERFORM_FULL_INSTALL()
        
  DIM iret AS Integer  
  ClsGlobal.sTargetMnt = "/mnt/target"
  
  WITH FMain
      .tvPlan["Inst2"].Selected = TRUE
      .tvPlan["Inst2"].Picture = MdlCore.sNowPic
      .tvPlan["Inst1"].Picture = MdlCore.sDonePic
    END WITH   
  
    iPkgCnt = MdlSetup.CALCULATE_PACKAGE_COUNT(FALSE)
    Message.Info("Total packages = " & iPkgCnt)
    PRINT "Installing bulks"
    MdlSetup.SHOW_PROGRESS_CONTROLS()
    iret = ME.INSTALL_BULK_PACKAGES()
  IF iret <> 0 THEN 
    PRINT "Error installing bulks ... exit"
    RETURN 
  END IF
  PRINT "installing packages"
  MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = ME.INSTALL_PACKAGES_NEW()
    IF iret <> 0 THEN 
      PRINT "error installing packages ... exit"
      RETURN 
    END IF
    PRINT "Installing packages/required"
    MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = ME.INSTALL_REQUIRED_PACKAGES()
    IF iret <> 0 THEN 
      PRINT "Error installing packages/required ... exit"
      RETURN 
    END IF
    PRINT "installing CONFIG packages from SETUP.CONF"
    MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = ME.INSTALL_CONFIG_PACKAGES()
      IF iret <> 0 THEN 
        PRINT "Error installing config packages ... exit"
        RETURN 
      END IF
      PRINT "installing kernels"
      MdlSetup.SHOW_PROGRESS_CONTROLS()
  iret = MdlInstallCustom.INSTALL_KERNELS()
    IF iret <> 0 THEN 
      PRINT "Error installing kernels ... exit "
      RETURN 
    END IF
    
    ' WRITE THE FSTAB NOW
  MdlInstallSys.WRITE_NEW_FSTAB()
  FrmInstallSys.pbInstallProg.Value = 1
  FrmInstallSys.pbInstallProg2.Value = 1
  Message.Info("Vectorlinux is now installed in your system. Please Exit the installer")
  WITH FMain
    .btQuit.Enabled = TRUE
    .btQuit.ForeColor = Color.Black
  END WITH 
  'MdlCore.unlock_gui()      
END


PUBLIC FUNCTION INSTALL_PACKAGES_NEW() AS Integer
  
  DIM sFile AS String = File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT")
  DIM arrFile AS String[]
  DIM i AS Integer
  DIM sLine AS String
  DIM vPgsSize AS Variant
  DIM sPkgPath AS String
  DIM sPkgName AS String
  DIM vTargetSize AS Variant  
      
      arrFile = Split(sFile, "\n")
        FOR i = 0 TO arrFile.Count - 1
          FrmInstallSys.pbInstallProg.Value = 0
          sLine = Trim(arrFile[i])
            IF Left(sLine, Len("PACKAGE_NAME")) = "PACKAGE NAME" THEN 
              sPkgName = Trim(Right(sLine, Len(sLine) - InStr(sLine, ":")))
              sPkgPath = Right(Right(arrFile[i + 1], Len(arrFile[i + 1]) - InStr(arrFile[i + 1], ":")), -4)
              vPgsSize = Left(Right(arrFile[i + 3], Len(arrFile[i + 3]) - InStr(arrFile[i + 3], ":")), -2)
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sPkgName & " ..."
                ' now install the package
                 SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO vTargetSize
                    PRINT "installing " & ClsGlobal.sSourceMnt &/ "packages" &/ sPkgPath &/ sPkgName
                    INC iPkgNum
                    ME.PACKAGE_INSTALL(ClsGlobal.sSourceMnt &/ "packages" &/ sPkgPath &/ sPkgName)
                      WAIT 
                        IF hproc.State = Process.Running THEN 
                          REPEAT 
                            WAIT 1
                              ' update progress here
                              ME.UPDATE_STEP_PROGRESS(CFloat(vTargetSize), CFloat(vPgsSize))
                          UNTIL 
                            hproc.State = Process.Stopped
                        END IF
            END IF
        FrmInstallSys.pbInstallProg.Value = 1
        WAIT 
        FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
        NEXT 
        'error check
                IF InStr(sDump, "FAILED") > 0 THEN 
                  PRINT sPkgName & " failed to install " 
                  RETURN 1
                ELSE 
                  RETURN 0
                END IF
END


PUBLIC FUNCTION INSTALL_BULK_PACKAGES() AS Integer
  DIM sRawList AS String
  DIM sList AS String[]
  DIM sCount AS String[]
  DIM sTrimmed AS String
  DIM sLineArr AS String[]
  DIM sBulkPath AS String
  DIM vBulkSize AS Variant
  DIM sBulkDesc AS String
  DIM vTargetSize AS Variant
  DIM i AS Integer
  'DIM sFile AS String = File.Load(ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF")
  DIM sLine AS String
  
     SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF | grep ^BULK" TO sRawList
     '   sList = Split(File.Load(Temp$("SETUP.CONF")), "\n")  
      sList = Split(sRawList, "\n")
      'PRINT sRawList & "srawlist " & sList.Count
        FOR i = 0 TO sList.count - 1
              'sLine = Trim(sList[i])
              'PRINT sList[i]
        IF Left(sList[i], Len("BULK")) = "BULK" THEN 
                
          sTrimmed = Right(sList[i], Len(sList[i]) - InStr(sList[i], "\'"))
          sTrimmed = Left(sTrimmed, InStr(sTrimmed, "\'") - 1)
          sLineArr = Split(sTrimmed, ":")
            sBulkPath = sLineArr[0]
            vBulkSize = sLineArr[1]
            sBulkDesc = sLineArr[2]
            'PRINT sBulkPath & vBulkSize & sBulkDesc
            FrmInstallSys.pbInstallProg.Value = 0
            INC iPkgNum
            SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO vTargetSize
                PRINT "installing " & sBulkPath  
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sBulkDesc & " ..."      
                'ME.BULK_INSTALL(ClsGlobal.sSourceMnt &/ "veclinux" &/ sBulkPath)
                hproc = SHELL "lzmadec <" & ClsGlobal.sSourceMnt &/ "veclinux" &/ sBulkPath & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
                PRINT sBulkPath
                  WAIT 1
                    IF hproc.State = Process.Running THEN 
                      REPEAT 
                        WAIT 3
                          ME.UPDATE_STEP_PROGRESS(CFloat(vTargetSize), CFloat(vBulkSize))
                      UNTIL 
                        hproc.State = Process.Stopped
                        'error check
                    END IF
                END IF  
        FrmInstallSys.pbInstallProg.Value = 1
        WAIT 
        FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)          
      NEXT 
'RETURN 
 IF InStr(sDump, "FAILED") > 0 THEN 
                RETURN 1
              ELSE 
                RETURN 0
              END IF
  
END


PUBLIC SUB BULK_INSTALL(sPath_to_bulk AS String)
    sDump = ""
    sErr = ""
  
    hproc = SHELL "lzmadec <" & sPath_to_bulk & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ  
END


PUBLIC SUB PACKAGE_INSTALL(sPath_To_Package AS String)
  
  sDump = ""
  sErr = ""
  hproc = SHELL "install-pkg " & sPath_To_Package & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ   
END


PUBLIC SUB PERFORM_FULL_INSTALL_OLD() AS Integer
  
  'Will need to read SETUP.CONF to determine what to do here
  
  DIM sFile AS String[]
  DIM sEntry AS String[]
  DIM stlzList AS String[]
  DIM sTlz AS String
  DIM sPak AS String
  DIM sPakPath AS String
  DIM sPakSize AS Variant
  DIM sTargetSize AS Variant
  DIM iTotalSize AS Integer
  DIM iCurrSize AS Variant
  DIM sPakDesc AS String
  DIM i AS Integer
  DIM ii AS Integer
  DIM sLine AS String
  DIM sBulkPath AS String
  DIM sConfPath AS String
  DIM sOptPkgPath AS String
  DIM iVal AS Float  
  DIM sBasePath AS String = ClsGlobal.sSourceMnt &/ "veclinux"
      
      WITH FrmInstallSys
        .Resize(FMain.pnlWinHost.Width, FMain.pnlWinHost.Height)
      END WITH 
  iPkgCnt = MdlSetup.CALCULATE_PACKAGE_COUNT(FALSE)
    Message.Info("Total packages = " & iPkgCnt)
  'RETURN 
  ' make sure the progress is revealed at the main window
    WITH FMain
    .tvPlan["Inst1"].Picture = MdlCore.sDonePic
    .tvPlan["Inst2"].Selected = TRUE
    .tvPlan["Inst2"].Picture = MdlCore.sNowPic
    END WITH   
  
  MdlSetup.SHOW_PROGRESS_CONTROLS()
  FrmInstallSys.tlBanner.Text = "Vectorlinux is now being installed. Please wait..."
  ClsGlobal.sTargetMnt = "/mnt/target"
    sFile = Split(File.Load(Temp$("SETUP.CONF")), "\n")
      FOR i = 0 TO sFile.count - 1
        sLine = Trim(sFile[i])
          IF Left(sLine, Len("BULK") + 1) LIKE "BULK" & "*[0-9]*" THEN 
            sLine = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
            sLine = Left(sLine, Len(sLine) - 1)
              sPak = Right(sLine, Len(sLine) - InStr(sLine, "\'"))
              sPak = Left(sPak, Len(sPak) - 1)
              sEntry = Split(sPak, ":")
                sPakPath = sEntry[0]
                sPakSize = sEntry[1]
                sPakDesc = sEntry[2]
                  'PRINT sBasePath &/ sPakPath & " = " & sPakDesc & " size= " & CStr(sPakSize)    
                      ' figure out the sizing and the progrss meter
                        SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
                          'Message(CStr(sTargetSize))
                          sTargetSize = Trim(CStr(sTargetSize))
                          sPakSize = Trim(CStr(sPakSize)) '                 
                          
                        'RETURN 
                FrmInstallSys.tlCurrPkg.Text = "Installing " & sPakDesc & " ..."
                FrmInstallSys.pbInstallProg.Value = 0.0
                
                PRINT "Installing " & sPakDesc & " Total size (KB) = " & CStr(sPakSize)
                sDump = ""
                sErr = ""
                  MdlCore.LOCK_GUI()
                  'inc iPkgNum
              hproc = SHELL "lzmadec <" & sBasePath &/ sPakPath & " | tar -xp -C " & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
              
                WAIT 2
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 2
                           UPDATE_STEP_PROGRESS(sTargetSize, sPakSize)                           
                    UNTIL 
                      hproc.State = Process.Stopped
                          ' error check
                            IF InStr(sDump, "FAILED") > 0 THEN 
                              Message.Error("There has been an error extracting " & sPakDesc & gb.NewLine &
                              "<b>ERROR</b>" & gb.NewLine &
                              sErr)
                              RETURN 1
                            ELSE 
                              FrmInstallSys.pbInstallProg.Value = 1                              
                  END IF
                PRINT sPak & " is installed... "
                INC iPkgNum
                              FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
                            END IF
           'PRINT "Needs to install " & sPak
          END IF
    NEXT 
  FrmInstallSys.tlBanner.Text = "Finished intalling Bulks"
  
        ' now to the packages individually
        ' FrmInstallSys.tlBanner.Text = "Installing additional software."
  ' ME.INSTALL_PACKAGES    
END


PUBLIC SUB UPDATE_STEP_PROGRESS(sTargetSize AS Float, sPakSize AS Float)
  
  DIM iMBProgress AS Float
  DIM ipct AS Float
  DIM iMinpct AS Float = ".01"
  DIM iMaxpct AS Float = ".99"
  DIM iVal AS Float
  DIM iProgress AS Float
  DIM iCurrSize AS Variant
 
  SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO iCurrSize
  iCurrSize = Trim(CStr(iCurrSize))
  iProgress = CInt(iCurrSize - sTargetSize)
  iMBProgress = iProgress / 1024
  IF iMBProgress > CFloat(sPakSize) THEN 
    iVal = iMaxpct
  ELSE 
    ipct = 100 * iMBProgress
    iVal = ipct / sPakSize * 10
    IF iVal < iMinpct THEN 
      iVal = iMinpct
    ENDIF 
    IF iVal > iMaxpct THEN 
      iVal = iMaxpct
    ENDIF 
  ENDIF 
  IF iVal > FrmInstallSys.pbInstallProg.Value THEN 
    FrmInstallSys.pbInstallProg.Value = iVal
  END IF
  PRINT CStr(iCurrSize) & "/" & CStr(sTargetSize + sPakSize) & " = " & iVal & "%"
END


PUBLIC FUNCTION INSTALL_PACKAGES() AS Integer
  
    DIM i AS Integer
    DIM sFile AS String[]
    DIM sLine AS String
    DIM sRawFile AS String
    DIM sTlzPath AS String
    DIM sTlzName AS String
    DIM sTlzDesc AS String
    DIM iTlzSize AS Integer
    DIM sTlzBasePath AS String = ClsGlobal.sSourceMnt &/ "packages"
    DIM sTargetSize AS Variant
    
    sRawFile = DConv(File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT"))
    
      sFile = Split(sRawFile, "\n")
        FOR i = 0 TO sFile.count - 1
          sLine = Trim(sFile[i])
            IF Left(sLine, Len("PACKAGE NAME")) = "PACKAGE NAME" THEN 
              sTlzName = Trim(Right(sLine, Len(sLine) - InStr(sLine, ":")))
              sTlzPath = Trim(Right(sFile[i + 1], Len(sFile[i + 1]) - InStr(sFile[i + 1], ":")))
              sTlzPath = Right(sTlzPath, Len(sTlzPath) - 2) ' remove the ./ from the location line
              iTlzSize = Trim(Right(sFile[i + 3], Len(sFile[i + 3]) - InStr(sFile[i + 3], ":")))
              'iTlzSize = Left(iTlzSize, Len(iTlzSize) - 1)
              'iTlzSize = Trim(iTlzSize)
              FrmInstallSys.tlCurrPkg.Text = "Installing " & sTlzName & " ..."
              FrmInstallSys.pbInstallProg.Value = 0.0
              
              PRINT " Install " & sTlzBasePath &/ sTlzPath &/ sTlzName 
                  ' install each package
               SHELL "export gsize=$(df| grep " & ClsPartSel.sRoot & " ) && echo $gsize | cut -f3 -d \' \'" TO sTargetSize
               sTargetSize = Trim(CStr(sTargetSize))
       
              sDump = ""
              sErr = ""
              hproc = SHELL "install-pkg " & sTlzBasePath &/ sTlzPath &/ sTlzName & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 1
                      UPDATE_STEP_PROGRESS(sTargetSize, iTlzSize)
                          ' figure out the progress again

                    UNTIL 
                      hproc.State = Process.Stopped
                          IF InStr(sDump, "FAILED") > 0 THEN 
                            ERROR 
                            RETURN 1
                          ELSE 
                            IF FrmInstallSys.pbInstallProg.Value <> 1 THEN 
                              FrmInstallSys.pbInstallProg.Value = 1
                            END IF
                          END IF
                  END IF
                  INC iPkgNum
                  FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
          END IF
      NEXT 
            
    ' DONE INSTALLING SOFTWARE. 
      'Message.Info("Installation complete. Ready for configuration"
      FrmInstallSys.tlBanner.Text = "Installation phase complete. Ready for configuration"
      FrmInstallSys.pbInstallProg.Value = 1
      MdlCore.unlock_gui()      
      FrmInstallSys.tlBanner.Text = "Installing default system configuration and required software."    
END


PUBLIC FUNCTION INSTALL_REQUIRED_PACKAGES() AS Integer
  
    DIM i AS Integer
    DIM sFile AS String[]
    DIM sLine AS String
    DIM sRawFile AS String
    DIM sTlzPath AS String
    DIM sTlzName AS String
    DIM sTlzDesc AS String
    DIM sTlzBasePath AS String = ClsGlobal.sSourceMnt &/ "packages"
    DIM iTlzTotal AS Integer = 0
    DIM iCurrTlz AS Integer '= 0
    MdlCore.LOCK_GUI()
    'sRawFile = DConv(File.Load(ClsGlobal.sSourceMnt &/ "packages" &/ "PACKAGES.TXT"))
     SHELL "ls /mnt/cdrom/packages/required/*.t?z" TO sRawFile
      sFile = Split(sRawFile, "\n")
        iTlzTotal = sFile.Count        
        FOR i = 0 TO sFile.count - 1
          sLine = Trim(sFile[i])
          INC iPkgNum  
          sTlzPath = Trim(sLine)
          ' now install the package with the information we already have
          PRINT sTlzName & sTlzPath
              'sDump = ""
              'sErr = ""
              FrmInstallSys.tlCurrPkg.Text = "Installing " & File.Name(sTlzPath) & " ..."
              'FrmInstallSys.pbInstallProg.Value = 0.0
              
               'figure out the progress again
                            ' for this one we will need to count the packages, and base our progress on the number of packages
                            ' installed vs the total number of packags
                            iCurrTlz = i
                            
              'hproc = SHELL "install-pkg " & sTlzPath & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
              ME.PACKAGE_INSTALL(sTlzPath)
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 2
                       
                            FrmInstallSys.pbInstallProg.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iTlzTotal, iCurrTlz)
                            FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
                    UNTIL 
                      hproc.State = Process.Stopped
'                      INC iPkgNum
                  END IF
        NEXT 
        FrmInstallSys.pbInstallProg.Value = 1
        WAIT 1
            
            IF InStr(sDump, "FAILED") > 0 THEN 
            PRINT "Error installing packages/required"
              RETURN 1
            ELSE 
            RETURN 0
          END IF
END


PUBLIC FUNCTION INSTALL_CONFIG_PACKAGES() AS Integer
    DIM sList AS String[]
    DIM sLinarr AS String[]
    DIM sRawList AS String
    DIM sPkg AS String
    DIM sCOnfLine AS String
    DIM sPkgPath AS String
    DIM i AS Integer
        
    PRINT "Installing final system configuration"
    SHELL "cat " & ClsGlobal.sSourceMnt &/ "veclinux" &/ "SETUP.CONF" & " | grep ^CONF" TO sRawList
    'Message.Info(sRawList)
    PRINT sRawList & " config"
'       IF InStr(sRawList, "\n") THEN 
'           PRINT "Multiple config files found ... starting at the top of the list"
'            
'       sList = Split(sRawList, "\n")
'        FOR i = 0 TO sList.count - 1
'         sCOnfLine = Trim(sList[i])
'           IF Left(sCOnfLine, Len("CONF")) = "CONF" THEN 
'             sPkg = Right(sCOnfLine, Len(sCOnfLine) - InStr(sCOnfLine, "\'"))
'                 'PRINT sPkg
'              sLinarr = Split(sPkg, ":")
'                 sPkgPath = sLinarr[0]
'                   
'                'PRINT sPkgPath
'                           ' now install the packages
'                           INC iPkgNum
'                           ' This may need to be installed as a bulk rather than a package
'                 'hproc = SHELL "install-pkg " & ClsGlobal.sSourceMnt &/ "veclinux" &/ sPkgPath & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
'                 ME.BULK_INSTALL(ClsGlobal.sSourceMnt &/ "veclinux" &/ sPkgPath)
'                  FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
'                 WAIT 1
'                   IF hproc.State = Process.Running THEN 
'                     REPEAT 
'                       WAIT 2
'                     UNTIL 
'                       hproc.State = Process.Stopped
' '                      INC iPkgNum
'                   END IF
'           END IF
'        NEXT 
'     ELSE  ' only one line found
      PRINT "Found a single CONF package... Installing it now"
        sRawList = Trim(sRawList)
          sLinarr = Split(sRawList, ":")
          sPkgPath = Right(sLinarr[0], Len(sLinarr[0]) - InStr(sLinarr[0], "\'"))
              ' now install the package
              FrmInstallSys.tlCurrPkg.Text = "Installing Final configuration files..."
              INC iPkgNum
                'hproc = SHELL "install-pkg " & sPkgPath & Space(1) & ClsGlobal.sTargetMnt & " || echo \'FAILED\'" FOR READ
                ME.BULK_INSTALL(ClsGlobal.sSourceMnt &/ "veclinux" &/ sPkgPath)
                 FrmInstallSys.pbInstallProg2.Value = MdlSetup.UPDATE_OVERALL_PROGRESS(iPkgCnt, iPkgNum)
                WAIT 1
                  IF hproc.State = Process.Running THEN 
                    REPEAT 
                      WAIT 2
                    UNTIL 
                      hproc.State = Process.Stopped
                  END IF
  ' END IF
    IF InStr(sDump, "FAILED") > 0 THEN 
      RETURN 1
    ELSE 
      RETURN 0
    END IF       
END


PUBLIC SUB Process_read()
  
  DIM sLine AS String
  READ #LAST, sLine, -256
  sDump = sDump & gb.NewLine & sLine
  PRINT sLine    
END

PUBLIC SUB process_error(msg AS String)

  sErr = sErr & gb.NewLine & sErr
  PRINT MSG
END 
